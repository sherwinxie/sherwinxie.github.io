<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon_xie.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_xie.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="sherwinxie,Hexo, NexT" />










<meta name="description" content="Doing is better than saying.">
<meta property="og:type" content="website">
<meta property="og:title" content="谢玮の技术Blog">
<meta property="og:url" content="http://sherwinxie.xyz/index.html">
<meta property="og:site_name" content="谢玮の技术Blog">
<meta property="og:description" content="Doing is better than saying.">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="谢玮の技术Blog">
<meta name="twitter:description" content="Doing is better than saying.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: 'IBBB7O55IY',
      apiKey: '689b1df622a8717252ea7fe5b9012794',
      indexName: 'sherwinxie',
      hits: {"per_page":10},
      labels: {"input_placeholder":"搜索谢玮的笔记","hits_empty":"抱歉，未在谢玮のBlog中发现您搜索的内容: ${query}","hits_stats":"发现 ${hits} 个结果，耗时 ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://sherwinxie.xyz/"/>





  <title>谢玮の技术Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">谢玮の技术Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">不积跬步，无以至千里，不积小流，无以成江海。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            About
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sherwinxie.xyz/装饰器模式总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SherwinX">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="谢玮の技术Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/装饰器模式总结/" itemprop="url">装饰器模式总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-03T00:00:00+08:00">
                2018-05-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是装饰器设计模式"><a href="#什么是装饰器设计模式" class="headerlink" title="什么是装饰器设计模式?"></a>什么是装饰器设计模式?</h2><h4 id="装饰器模式-Decorator-Pattern-："><a href="#装饰器模式-Decorator-Pattern-：" class="headerlink" title="装饰器模式(Decorator Pattern)："></a>装饰器模式(Decorator Pattern)：</h4><p>允许向一个现有的对象添加新的功能，同时又不改变其结构。装饰者可以在所委托被装饰者的行为之前或之后加上自己的行为，以达到特定的目的。</p>
<p>这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。</p>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ul>
<li><p>优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</p>
</li>
<li><p>缺点：多层装饰比较复杂。</p>
<h4 id="装饰器模式与代理模式的异同"><a href="#装饰器模式与代理模式的异同" class="headerlink" title="装饰器模式与代理模式的异同"></a>装饰器模式与代理模式的异同</h4></li>
<li><p>注意装饰器模式和静态代理的异同，相同的是：静态代理类也实现了被代理类的接口，和装饰器Decorator接口也实现了Component接口同理，所以可以把静态代理看成是装饰器模式的一种，即装饰器模式只有一个装饰类，不同的是：静态代理只能做一种功能增强，而装饰器可以做多种类的功能增强。</p>
</li>
<li>装饰器模式和动态代理就不是一个概念的了，装饰器模式关注于在一个对象上动态的添加方法，然而动态代理模式关注于控制对对象的访问。动态代理类不用实现被代理类的具体接口，动态代理本质是对被代理目标对象进行控制，而装饰器只是附加装饰没有控制权。<a href="">动态代理模式详见《代理模式总结》</a></li>
</ul>
<h4 id="UML类图："><a href="#UML类图：" class="headerlink" title="UML类图："></a>UML类图：</h4><p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1frjclu0ir1j317i0twn0p.jpg" alt="image"></p>
<p>抽象组件（Component）：需要装饰的抽象对象。<br><br>具体组件（ConcreteComponent）：是我们需要装饰的目标对象。<br><br>抽象装饰类（Decorator）：内含指向抽象组件的引用及装饰者共有的方法。<br><br>具体装饰类（ConcreteDecorator）：被装饰的对象A和B。<br></p>
<h4 id="装饰器模式应用"><a href="#装饰器模式应用" class="headerlink" title="装饰器模式应用"></a>装饰器模式应用</h4><blockquote>
<p>假设我们现在去咖啡店买一杯咖啡，可以加奶、加糖等等。咖啡和奶、糖分别有不同的价格。<br>咖啡就是我们的组件，奶和糖是我们的装饰者，现在我们要计算调制这样一杯咖啡花费多少。</p>
</blockquote>
<p>UML类图：<br><img src="https://ws2.sinaimg.cn/large/006tNc79ly1frje3e6k98j31720yotcd.jpg" alt="image"></p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现:"></a>代码实现:</h4><p>抽象Drink接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Drink</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">cost</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Coffe类:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> <span class="keyword">implements</span> <span class="title">Drink</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> String description = <span class="string">"coffee"</span>;</span><br><span class="line">    <span class="comment">//每杯 coffee 售价 10 元</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> description;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>饮品调料抽象类:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CondimentDecorator</span> <span class="keyword">implements</span> <span class="title">Drink</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Drink decoratorDrink;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CondimentDecorator</span><span class="params">(Drink decoratorDrink)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.decoratorDrink = decoratorDrink;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> decoratorDrink.cost();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> decoratorDrink.getDescription();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>牛奶调料类(装饰器):<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Milk</span> <span class="keyword">extends</span> <span class="title">CondimentDecorator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Milk</span><span class="params">(Drink decoratorDrink)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(decoratorDrink);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.cost() + <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getDescription() + <span class="string">" milk"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>糖糖调料类(装饰器):<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sugar</span> <span class="keyword">extends</span> <span class="title">CondimentDecorator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sugar</span><span class="params">(Drink decoratorDrink)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(decoratorDrink);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.cost() + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getDescription() + <span class="string">" sugar"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>咖啡店类(Client)：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoffeeShop</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//点一杯coffee(被装饰对象)</span></span><br><span class="line">        Drink drink = <span class="keyword">new</span> Coffee();</span><br><span class="line">        System.out.println(drink.getDescription() + <span class="string">"价格"</span> + drink.cost());</span><br><span class="line">        <span class="comment">//加一份奶(装饰器)</span></span><br><span class="line">        drink = <span class="keyword">new</span> Milk(drink);</span><br><span class="line">        System.out.println(drink.getDescription() + <span class="string">"价格"</span> + drink.cost());</span><br><span class="line">        <span class="comment">//加一份糖</span></span><br><span class="line">        drink = <span class="keyword">new</span> Sugar(drink);</span><br><span class="line">        System.out.println(drink.getDescription() + <span class="string">"价格"</span> + drink.cost());</span><br><span class="line">        <span class="comment">//再加一份糖</span></span><br><span class="line">        drink = <span class="keyword">new</span> Sugar(drink);</span><br><span class="line">        System.out.println(drink.getDescription() + <span class="string">"价格"</span> + drink.cost());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果:  </p>
<blockquote>
<p>coffee价格10.0<br>coffee milk价格13.0<br>coffee milk sugar价格14.0<br>coffee milk sugar sugar价格15.0</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sherwinxie.xyz/责任链模式总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SherwinX">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="谢玮の技术Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/责任链模式总结/" itemprop="url">责任链模式总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-02T00:00:00+08:00">
                2018-05-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是责任链模式？"><a href="#什么是责任链模式？" class="headerlink" title="什么是责任链模式？"></a>什么是责任链模式？</h2><h4 id="责任链模式-Chain-of-Responsibility-Pattern）的定义："><a href="#责任链模式-Chain-of-Responsibility-Pattern）的定义：" class="headerlink" title="责任链模式(Chain of Responsibility Pattern）的定义："></a>责任链模式(Chain of Responsibility Pattern）的定义：</h4><p>为请求创建了一个接收者对象的职责链，使多个接受者对象都有机会处理请求，从而对请求的发送者和接收者进行解耦。将这些接受者对象连成一条链，并沿着这条链传递该请求，通常每个接收者都包含对另一个接收者的引用，如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，直到有一个对象处理它为止。</p>
<p>责任链属于行为型模式。</p>
<blockquote>
<p>大话设计模式中，程杰老师给出的定义是责任链模式：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。</p>
</blockquote>
<blockquote>
<p>在责任链模式中发出请求的客户端并不知道这当中的哪个接受对象最终处理这个请求，这样系统的更改可以在不影响客户端的情况下动态的重新组织和分配责任。</p>
</blockquote>
<h4 id="主要解决"><a href="#主要解决" class="headerlink" title="主要解决:"></a>主要解决:</h4><p>职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。</p>
<h4 id="代表应用："><a href="#代表应用：" class="headerlink" title="代表应用："></a>代表应用：</h4><ul>
<li>JS 中的事件冒泡</li>
<li>JAVA WEB 中 Apache Tomcat 对 Encoding 的处理</li>
<li>JSP Servlet 的 Filter过滤器, ..</li>
<li>Struts2 的拦截器</li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li>降低耦合度。它将请求的发送者和接收者解耦，即分离了请求与处理，无须知道是哪个对象处理其请求。 </li>
<li>简化了对象的相互连接。使得对象不需要知道链的结构。即仅保持一个指向后者的引用，而不需保持所有候选接受者的引用结构。</li>
<li>增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。</li>
<li>增加新的请求处理类很方便，只需要在客户端重新建链即可，无需破坏原代码</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>不能保证请求一定被接收处理，如果请求没有明确的接收者，那么就不能保证它一定会被处理，该请求可能一直到链的末端都得不到处理；一个请求也可能因职责链没有被正确配置而得不到处理</li>
<li>较长的职责链，请求的处理可能涉及到多个处理对象，系统性能将受到一定影响，而且在进行代码调试时不太方便，如果建链不当，可能会造成循环调用，将导致系统陷入死循环。 </li>
<li>可能不容易观察运行时的特征，有碍于Debug。</li>
</ol>
<h2 id="责任链代码应用"><a href="#责任链代码应用" class="headerlink" title="责任链代码应用"></a>责任链代码应用</h2><p>如A的职责可以处理0-9天的请假，B可以处理10-19天的，C可以处理20-29天的权利，如请求超过30天，则不被处理。现实意义比喻是要么请假30天内，要么get off。。</p>
<h4 id="结构解析"><a href="#结构解析" class="headerlink" title="结构解析"></a>结构解析</h4><blockquote>
<p>Handler定义一个处理请示的抽象类或接口；</p>
<p>ConcreteHandler代表具体处理者类对象，处理它所负责的请求，可访问它的后继者，如果”职责”可以处理该请求，就处理，否则就将该请求转发给它的后继者。</p>
</blockquote>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现:"></a>代码实现:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Handler successor;<span class="comment">//后继者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Handler <span class="title">getSuccessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> successor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSuccessor</span><span class="params">(Handler successor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.successor = successor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理请求</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(<span class="keyword">int</span> request)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当请求数在0~9天之间时A有权处理，否则转到下一位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteHandlerA</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(<span class="keyword">int</span> request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request &gt;= <span class="number">0</span> &amp;&amp; request &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.getClass() + <span class="string">"  处理请求  "</span> + request);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (successor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            successor.handleRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当请求数在10~19之间时B有权处理，否则转到下一位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteHandlerB</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(<span class="keyword">int</span> request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request &gt;= <span class="number">10</span> &amp;&amp; request &lt; <span class="number">20</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.getClass() + <span class="string">"  处理请求  "</span> + request);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (successor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            successor.handleRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当请求数在20~29之间时C有权处理，否则转到下一位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteHandlerC</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(<span class="keyword">int</span> request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request &gt;= <span class="number">20</span> &amp;&amp; request &lt; <span class="number">30</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.getClass() + <span class="string">"  处理请求  "</span> + request);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (successor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            successor.handleRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChainPatternDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Handler handlerA = <span class="keyword">new</span> ConcreteHandlerA();</span><br><span class="line">        Handler handlerB = <span class="keyword">new</span> ConcreteHandlerB();</span><br><span class="line">        Handler handlerC = <span class="keyword">new</span> ConcreteHandlerC();</span><br><span class="line">        <span class="comment">//设置责任链的前驱和后继</span></span><br><span class="line">        handlerA.setSuccessor(handlerB);</span><br><span class="line">        handlerB.setSuccessor(handlerC);</span><br><span class="line">        <span class="comment">//客户端只要将不同的请假天数都交给A处理 </span></span><br><span class="line">        <span class="keyword">int</span>[] requests = &#123;<span class="number">2</span>,<span class="number">10</span>,<span class="number">4</span>,<span class="number">22</span>,<span class="number">18</span>,<span class="number">27</span>,<span class="number">30</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> request : requests) &#123;</span><br><span class="line">            handlerA.handleRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<p>A的职责处理0-9天，B处理10-19，C处理20至29,30不在职责链内所以未处理未打印出来。</p>
<blockquote>
<p>class Chain.ConcreteHandlerA  处理请求  2<br>class Chain.ConcreteHandlerB  处理请求  10<br>class Chain.ConcreteHandlerA  处理请求  4<br>class Chain.ConcreteHandlerC  处理请求  22<br>class Chain.ConcreteHandlerB  处理请求  18<br>class Chain.ConcreteHandlerC  处理请求  27</p>
</blockquote>
<h4 id="关于纯与不纯"><a href="#关于纯与不纯" class="headerlink" title="关于纯与不纯"></a>关于纯与不纯</h4><ul>
<li>纯：要么承担全部责任，要么将责任推给下家，不允许出现某一个具体处理者对象在承担了一部分或全部责任后又将责任向下传递的情况。</li>
<li>不纯：允许某个请求被一个具体处理者部分处理后再向下传递，或者一个具体处理者处理完某请求后其后继处理者可以继续处理该请求，而且一个请求可以最终不被任何处理者对象所接收。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>职责链模式通过建立一条链来组织请求的处理者，请求将沿着链进行传递，请求发送者无须知道请求在何时、何处以及如何被处理，实现了请求发送者与处理者的解耦。在软件开发中，如果遇到有多个对象可以处理同一请求时可以应用职责链模式，例如在Web应用开发中创建一个过滤器(Filter)链来对请求数据进行过滤，在工作流系统中实现公文的分级审批等等，使用职责链模式可以较好地解决此类问题。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sherwinxie.xyz/OODandOOP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SherwinX">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="谢玮の技术Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/OODandOOP/" itemprop="url">面向对象设计原则及常见模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-02T00:00:00+08:00">
                2018-05-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="面向对象编程-OOP-三特性"><a href="#面向对象编程-OOP-三特性" class="headerlink" title="面向对象编程(OOP)三特性"></a>面向对象编程(OOP)三特性</h2><ul>
<li>封装(Encapsulation)</li>
<li>继承(Inheritance)</li>
<li>多态(Polymorphism)</li>
</ul>
<p>其实还有一个特性叫 抽象(Abstraction)</p>
<h4 id="这里主要说说多态-前提条件："><a href="#这里主要说说多态-前提条件：" class="headerlink" title="这里主要说说多态 前提条件："></a>这里主要说说多态 前提条件：</h4><ul>
<li>1.要有继承关系</li>
<li>2.子类要重写父类的方法</li>
<li>3.父类引用指向子类对象</li>
</ul>
<h4 id="多态的动态绑定-也叫延迟绑定"><a href="#多态的动态绑定-也叫延迟绑定" class="headerlink" title="多态的动态绑定(也叫延迟绑定)"></a>多态的动态绑定(也叫延迟绑定)</h4><p>方法的动态绑定是指，在程序运行期间判断对象变量所引用的对象的实际类型，根据其实际类型调用相应的方法。</p>
<h4 id="多态的向上转型"><a href="#多态的向上转型" class="headerlink" title="多态的向上转型"></a>多态的向上转型</h4><p>多态的向上转型只能访问父类中声明的成员</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Animal animal = <span class="keyword">new</span> Cat(<span class="string">"Luck"</span>,<span class="string">"gray"</span>);<span class="comment">// 向上转型 animal只能访问父类的成员</span></span><br></pre></td></tr></table></figure>
<h4 id="多态的向下转型"><a href="#多态的向下转型" class="headerlink" title="多态的向下转型"></a>多态的向下转型</h4><p>多态的缺点是不能直接使用子类特有的成员属性和子类特有的成员方法，解决方案是强制向下转型。</p>
<p>多态的魅力在于，通过强制向下转型,多态的缺点将会变成其灵活的优点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cat animalCat = (Cat)animal; <span class="comment">// 强制向下转型 animalCat就可以访问子类的成员</span></span><br></pre></td></tr></table></figure></p>
<p>animalCat就指向最开始堆内存中创建的Cat对象了，减少了多余对象的创建，不用为了使用某个子类方法又去重新在Heap中开辟一个新的子类对象。根据里氏替换原则，子类就可以替换其父类。</p>
<h2 id="OOD的七大设计原则-（SOLID-Demeter-Composite）"><a href="#OOD的七大设计原则-（SOLID-Demeter-Composite）" class="headerlink" title="OOD的七大设计原则 （SOLID + Demeter + Composite）"></a>OOD的七大设计原则 （SOLID + Demeter + Composite）</h2><h4 id="1-单一职责原则（Single-Responsibility-Principle）"><a href="#1-单一职责原则（Single-Responsibility-Principle）" class="headerlink" title="1. 单一职责原则（Single Responsibility Principle）"></a>1. 单一职责原则（Single Responsibility Principle）</h4><p>核心：解耦和增强内聚性（高内聚，低耦合）</p>
<p>每一个类最好专注于做一件事情和仅有一个引起它变化的原因，通常意义下的单一职责，就是指只有一种单一功能，多个职责耦合在一起，会影响复用性，不要为类实现过多的功能点，以保证实体只有一个引起它变化的原因。</p>
<h4 id="2-开闭原则（Open-Close-Principle）"><a href="#2-开闭原则（Open-Close-Principle）" class="headerlink" title="2. 开闭原则（Open Close Principle）"></a>2. 开闭原则（Open Close Principle）</h4><p>面向扩展开放，面向修改关闭。</p>
<h4 id="3-里氏替换原则（Liskov-Substitution-Principle）"><a href="#3-里氏替换原则（Liskov-Substitution-Principle）" class="headerlink" title="3. 里氏替换原则（Liskov Substitution Principle）"></a>3. 里氏替换原则（Liskov Substitution Principle）</h4><p>核心:子类必须能够替换其父类。</p>
<p>这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。在父类和子类的具体行为中，必须严格把握继承层次中的关系和特征，将基类替换为子类，程序的行为不会发生任何变化。同时，这一约束反过来则是不成立的，子类可以替换基类，但是基类不一定能替换子类。</p>
<h4 id="4-接口隔离原则（Interface-Segregation-Principle）"><a href="#4-接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="4. 接口隔离原则（Interface Segregation Principle）"></a>4. 接口隔离原则（Interface Segregation Principle）</h4><p>接口隔离有两种定义：</p>
<ul>
<li>客户端不应该依赖它不需要的接口 </li>
<li>类间的依赖关系应该建立在最小的接口上，即要求接口细化，接口纯洁。</li>
</ul>
<p>其核心思想是：使用多个小而细化的接口，而不要使用一个大的总接口。接口虽然要尽量小，但是小也是有限度的，不能违背单一职责原则。</p>
<p>实际开发中注意：</p>
<ul>
<li>一个接口只服务于一个子模块或业务逻辑</li>
<li>通过业务逻辑压缩接口中的public方法，接口要不断的精简，以达到接口不断完善</li>
<li>已经被污染的接口，尽量去修改，若变更的风险较大，则采用适配器进行转化处理</li>
</ul>
<h4 id="5-依赖倒置原则（Dependence-Inversion-Principle）"><a href="#5-依赖倒置原则（Dependence-Inversion-Principle）" class="headerlink" title="5. 依赖倒置原则（Dependence Inversion Principle）"></a>5. 依赖倒置原则（Dependence Inversion Principle）</h4><p>依赖倒置原则(Dependence Inversion Principle ,DIP)定义如下：</p>
<p>High level modules should not depend upon low level modules,Both should depend upon abstractions.Abstractions should not depend upon details.Details should depend upon abstracts.</p>
<p>翻译过来为：</p>
<ul>
<li>高层模块不应该依赖低层模块，两者都应该依赖抽象</li>
<li>抽象不应该依赖细节 </li>
<li>细节应该依赖抽象</li>
</ul>
<p>也可以说高层模块，低层模块，细节都应该依赖抽象，这样做的好处是松耦合，高内聚，扩展灵活性高</p>
<p>依赖倒置原则在java语言中，表现是：</p>
<ul>
<li>模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的。</li>
<li>接口或抽象类不依赖实现类</li>
<li>实现类依赖接口或抽象类</li>
</ul>
<h4 id="6-迪米特法则（Law-Of-Demeter）"><a href="#6-迪米特法则（Law-Of-Demeter）" class="headerlink" title="6. 迪米特法则（Law Of Demeter）"></a>6. 迪米特法则（Law Of Demeter）</h4><p>又叫最少知道原则，一个类对自己依赖的类知道的越少越好也就是一个对象就尽可能少的去了解其它对象，从而实现松耦合。也就是说，对于被依赖的类来说，无论逻辑多么复杂，都尽量地的将逻辑封装在类的内部，对外除了提供的public方法，不对外泄漏任何信息。</p>
<p>迪米特法则的简单定义：只与直接的朋友通信。</p>
<p>解释一下什么是直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖、关联、组合、聚合等。其中，当前对象本身（this）、成员变量、以参数形式传入当前对象方法中的对象、方法返回值中的类，当前对象创建的对象为直接的朋友。</p>
<p>使用总结：</p>
<ul>
<li>在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大影响；</li>
<li>在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限；</li>
<li>在类的设计上，只要有可能，一个类型应当设计成不变类；</li>
<li>在对其他类的引用上，一个对象对其他对象的引用应当降到最低。</li>
</ul>
<h4 id="7-组合-聚合复用原则（Composite-Aggregate-Reuse-Principle-CARP）"><a href="#7-组合-聚合复用原则（Composite-Aggregate-Reuse-Principle-CARP）" class="headerlink" title="7. 组合/聚合复用原则（Composite/Aggregate Reuse Principle CARP）"></a>7. 组合/聚合复用原则（Composite/Aggregate Reuse Principle CARP）</h4><p>尽量使用组合/聚合达到复用，尽量少用继承。使用原则：一个类中有另一个类的对象。</p>
<p>子类是父类的一个特殊种类，而不是超类的一个角色，也就是区分“Has-A”和“Is-A”.只有“Is-A”关系才符合继承关系，“Has-A”关系应当使用聚合来描述。</p>
<h2 id="OOP设计模式："><a href="#OOP设计模式：" class="headerlink" title="OOP设计模式："></a>OOP设计模式：</h2><h3 id="设计模式是什么"><a href="#设计模式是什么" class="headerlink" title="设计模式是什么?"></a>设计模式是什么?</h3><p>简单来说，设计模式是一种利用OOP的封闭、继承和多态三大特性，同时在遵循七大设计原则：单一职责原则、开闭原则、里氏替换原则、迪米特法则、依赖倒置原则、接口隔离原则及合成/聚合复用原则的前提下，被总结出来的经过反复实践并被多数人知晓且经过分类和设计的可重用的软件设计方式，设计模式远不止Gof提出的23种。</p>
<h3 id="为什么学设计模式"><a href="#为什么学设计模式" class="headerlink" title="为什么学设计模式?"></a>为什么学设计模式?</h3><p>设计模式虽然都有其相对固定的实现方式，但是它的精髓是利用OOP的三大特性，遵循OOD七大原则解决工程问题。所以学习设计模式的目的不是学习设计模式的固定实现方式本身，而是其思想本身。</p>
<h3 id="设计模式分类-How"><a href="#设计模式分类-How" class="headerlink" title="设计模式分类(How)"></a>设计模式分类(How)</h3><table>
<thead>
<tr>
<th>模式类型</th>
<th>包含</th>
</tr>
</thead>
<tbody>
<tr>
<td>创建型模式<br>这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式。</td>
<td>工厂模式（Factory Pattern）<br>抽象工厂模式（Abstract Factory Pattern）<br>单例模式（Singleton Pattern）<br>建造者模式（Builder Pattern）<br>原型模式（Prototype Pattern）</td>
</tr>
<tr>
<td>结构型模式<br>这些设计模式关注类和对象的组合。</td>
<td>适配器模式（Adapter Pattern）<br>桥接模式（Bridge Pattern）<br>过滤器模式（Filter、Criteria Pattern）<br>组合模式（Composite Pattern）<br>装饰器模式（Decorator Pattern）<br>外观模式（Facade Pattern）<br>享元模式（Flyweight Pattern）<br>代理模式（Proxy Pattern）</td>
</tr>
<tr>
<td>行为型模式<br>这些设计模式特别关注对象之间的通信。</td>
<td>责任链模式（Chain of Responsibility Pattern）<br>命令模式（Command Pattern）<br>解释器模式（Interpreter Pattern）<br>迭代器模式（Iterator Pattern）<br>中介者模式（Mediator Pattern）<br>备忘录模式（Memento Pattern）<br>观察者模式（Observer Pattern）<br>状态模式（State Pattern）<br>空对象模式（Null Object Pattern）<br>策略模式（Strategy Pattern）<br>模板模式（Template Pattern）<br>访问者模式（Visitor Pattern）</td>
</tr>
</tbody>
</table>
<h4 id="工厂模式（Factory-Pattern）"><a href="#工厂模式（Factory-Pattern）" class="headerlink" title="工厂模式（Factory Pattern）"></a>工厂模式（Factory Pattern）</h4><p><a href="https://sherwinxie.xyz/design/工厂模式总结/">静态工厂/工厂方法/抽象工厂设计模式</a></p>
<h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p><a href="https://sherwinxie.xyz/design/单例模式总结/">单例模式</a></p>
<h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><p><a href="https://sherwinxie.xyz/design/代理模式总结/">静态代理/动态代理</a></p>
<h4 id="责任链"><a href="#责任链" class="headerlink" title="责任链"></a>责任链</h4><p><a href="https://sherwinxie.xyz/design/责任链模式总结/">责任链设计模式</a></p>
<h4 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h4><p><a href="https://sherwinxie.xyz/design/装饰器模式总结/">装饰模式</a></p>
<h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><p><a href="https://sherwinxie.xyz/design/工厂模式总结/">观察者模式</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sherwinxie.xyz/代理模式总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SherwinX">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="谢玮の技术Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/代理模式总结/" itemprop="url">代理模式总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-01T00:00:00+08:00">
                2018-05-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是代理模式-amp-为什么用？"><a href="#什么是代理模式-amp-为什么用？" class="headerlink" title="什么是代理模式&amp;为什么用？"></a>什么是代理模式&amp;为什么用？</h2><p>代理(Proxy)是一种结构型设计模式,提供了对目标对象另外的访问方式，即通过代理对象访问目标对象。</p>
<p>这样做的好处是:可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能。</p>
<p>这里使用到编程中的一个思想:不要随意去修改别人已经写好的代码或者方法,如果需改修改,可以通过代理的方式来扩展该方法。</p>
<p>代理模式分静态代理和动态代理，关于动态代理的应用在Spring中的AOP，Struts2中的拦截器等。</p>
<h4 id="代理模式一般会涉及到的角色："><a href="#代理模式一般会涉及到的角色：" class="headerlink" title="代理模式一般会涉及到的角色："></a>代理模式一般会涉及到的角色：</h4><p>抽象角色：声明目标对象和代理对象的共同接口,这样一来在任何可以使用目标对象的地方都可以使用代理对象。</p>
<p>真实角色：定义了代理对象所代表的目标对象，是我们最终要引用的对象。</p>
<p>代理角色：代理对象内部含有目标对象的引用，从而可以在任何时候操作目标对象；代理对象提供一个与目标对象相同的接口，以便可以在任何时候替代目标对象。代理对象通常在客户端调用传递给目标对象之前或之后，执行某个操作，而不是单纯地将调用传递给目标对象，同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装。</p>
<h2 id="静态代理的使用"><a href="#静态代理的使用" class="headerlink" title="静态代理的使用"></a>静态代理的使用</h2><p>我们先来看一种无代理的模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> <span class="keyword">implements</span> <span class="title">IUserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"----已经保存数据!----"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上没有代理的使用，如现在要加入事务，开启事务和提交事务就需要加入到save()方法中，这样做会牺牲方法的单一职责和其灵活拓展性。</p>
<h3 id="引入静态代理："><a href="#引入静态代理：" class="headerlink" title="引入静态代理："></a>引入静态代理：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用代理对象,静态代理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoProxy</span> <span class="keyword">implements</span> <span class="title">IUserDao</span></span>&#123;</span><br><span class="line">    <span class="comment">//接收保存目标对象</span></span><br><span class="line">    <span class="keyword">private</span> IUserDao target;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserDaoProxy</span><span class="params">(IUserDao target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target=target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开始事务..."</span>);</span><br><span class="line">        target.save();<span class="comment">//执行目标对象的方法</span></span><br><span class="line">        System.out.println(<span class="string">"提交事务..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //目标对象</span><br><span class="line">        UserDao target = new UserDao();</span><br><span class="line"></span><br><span class="line">        //代理对象,把目标对象传给代理对象,建立代理关系</span><br><span class="line">        UserDaoProxy proxy = new UserDaoProxy(target);</span><br><span class="line"></span><br><span class="line">        proxy.save();//执行的是代理的方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态代理优点:<br>可以做到在不修改目标对象的功能前提下,对目标功能扩展.</p>
<p>缺点:</p>
<p>因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类,类太多.同时,一旦接口增加方法,目标对象与代理对象都要维护.</p>
<p>如何解决静态代理中的缺点呢?答案是可以使用动态代理方式</p>
<h2 id="动态代理的使用"><a href="#动态代理的使用" class="headerlink" title="动态代理的使用"></a>动态代理的使用</h2><p>动态代理有以下特点:</p>
<ul>
<li>代理对象,不需要实现具体接口 </li>
<li>代理对象的生成,是利用JDK的API,动态的在内存中构建代理对象(需要我们指定创建代理对象/目标对象实现的接口的类型)</li>
<li>动态代理也叫做:JDK代理,接口代理</li>
</ul>
<h4 id="JDK中生成代理对象的API"><a href="#JDK中生成代理对象的API" class="headerlink" title="JDK中生成代理对象的API"></a>JDK中生成代理对象的API</h4><p>代理类所在包:java.lang.reflect.Proxy</p>
<p>JDK实现代理只需要使用newProxyInstance方法,但是该方法需要接收三个参数,完整的写法是:</p>
<p>static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler h )</p>
<p>注意该方法是在Proxy类中是静态方法,且接收的三个参数依次为:</p>
<ul>
<li>ClassLoader loader, 指定当前目标对象使用类加载器,获取加载器的方法是固定的</li>
<li>Class&lt;?&gt;[] interfaces, 目标对象实现的接口的类型,使用泛型方式确认类型</li>
<li>InvocationHandler h 事件处理,执行目标对象的方法时,会触发事件处理器的方法,会把当前执行目标对象的方法作为参数传入</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建动态代理对象</span></span><br><span class="line"><span class="comment"> * 动态代理不需要实现接口,但是需要指定接口类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span></span>&#123;</span><br><span class="line">    <span class="comment">//维护一个目标对象</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyFactory</span><span class="params">(Object target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target=target;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//给目标对象生成代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">                target.getClass().getClassLoader(),</span><br><span class="line">                target.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                    <span class="meta">@Override</span><span class="comment">//匿名内部类方式重写invoke方法</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">"开始事务2"</span>);</span><br><span class="line">                        <span class="comment">//执行目标对象方法</span></span><br><span class="line">                        Object returnValue = method.invoke(target, args);</span><br><span class="line">                        System.out.println(<span class="string">"提交事务2"</span>);</span><br><span class="line">                        <span class="keyword">return</span> returnValue;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在JDK动态代理中，我们一方面将原本代理对象中的引用类型由具体类型改为(invoke 方法)Object基类型，另一方面将方法的调用过程改为通过反射的方式，实现了部依赖于具体接口的具体方法，便成功代理被代理对象方法的效果。</p>
<p>测试类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 目标对象</span></span><br><span class="line">        IUserDao target = <span class="keyword">new</span> UserDao();</span><br><span class="line">        <span class="comment">// 【原始的类型 UserDao】</span></span><br><span class="line">        System.out.println(target.getClass());</span><br><span class="line">        <span class="comment">// 给目标对象，创建代理对象</span></span><br><span class="line">        IUserDao proxy = (IUserDao) <span class="keyword">new</span> ProxyFactory(target).getProxyInstance();</span><br><span class="line">        <span class="comment">// class $Proxy0   内存中动态生成的代理对象</span></span><br><span class="line">        System.out.println(proxy.getClass());</span><br><span class="line">        <span class="comment">// 执行方法   【代理对象】</span></span><br><span class="line">        proxy.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Cglib代理"><a href="#Cglib代理" class="headerlink" title="Cglib代理"></a>Cglib代理</h2><p>上面的静态代理和动态代理模式都是要求目标对象是实现一个接口的目标对象,但是有时候目标对象只是一个单独的对象,并没有实现任何的接口,这个时候就可以使用以目标对象子类的方式类实现代理,这种方法就叫做:Cglib代理</p>
<p>Cglib代理,也叫作子类代理,它是在内存中构建一个子类对象从而实现对目标对象功能的扩展.</p>
<p>JDK的动态代理有一个限制,就是使用动态代理的对象必须实现一个或多个接口,如果想代理没有实现接口的类,就可以使用Cglib实现.</p>
<p>Cglib是一个强大的高性能的代码生成包,它可以在运行期扩展java类与实现java接口.它广泛的被许多AOP的框架使用,例如Spring AOP和synaop,为他们提供方法的interception(拦截).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标对象,没有实现任何接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"----已经保存数据!----"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Cglib子类代理工厂</span></span><br><span class="line"><span class="comment"> * 对UserDao在内存中动态构建一个子类对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span></span>&#123;</span><br><span class="line">    <span class="comment">//维护目标对象</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyFactory</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给目标对象创建一个代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.工具类</span></span><br><span class="line">        Enhancer en = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">//2.设置父类</span></span><br><span class="line">        en.setSuperclass(target.getClass());</span><br><span class="line">        <span class="comment">//3.设置回调函数</span></span><br><span class="line">        en.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//4.创建子类(代理对象)</span></span><br><span class="line">        <span class="keyword">return</span> en.create();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开始事务..."</span>);</span><br><span class="line">        <span class="comment">//执行目标对象的方法</span></span><br><span class="line">        Object returnValue = method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">"提交事务..."</span>);</span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//目标对象</span></span><br><span class="line">        UserDao target = <span class="keyword">new</span> UserDao();</span><br><span class="line">        <span class="comment">//代理对象</span></span><br><span class="line">        UserDao proxy = (UserDao)<span class="keyword">new</span> ProxyFactory(target).getProxyInstance();</span><br><span class="line">        <span class="comment">//执行代理对象的方法</span></span><br><span class="line">        proxy.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>优点：可以为没有借口的类 包装前置和后置方法，从这点来说，它比静态代理和JDK的动态代理还要灵活。</p>
<p>缺点：JDK动态代理根据接口信息来拦截特定的方法，而CGLib动态代理没有借口信息，它拦截了被代理对象的所有方法。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这三种代理代理模式各有优劣，它们的优点在于</p>
<ul>
<li>我们从原有的调用逻辑过程，抽了一个代理类的方式，使调用逻辑的变化尽可能的封装在代理类的内部，达到不去改动原有被代理类的方法的情况下，增加新的动作效果。</li>
<li>这使得即便未来有更多的拓展，改变也依然很难波及被代理类，我们就可以放心的对被代理类的方法进行服复用了。</li>
</ul>
<p>从缺点来看：</p>
<ul>
<li>静态代理和JDK动态代理都需要被代理类的接口信息以确定特定的方法进行包装和拦截。</li>
<li>CGLib动态代理虽然不需要接口信息，但是它拦截并包装被代理类的所有方法。</li>
</ul>
<p>在Spring的AOP编程中:<br>如果加入容器的目标对象有实现接口,用JDK代理，如果目标对象没有实现接口,用Cglib代理。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sherwinxie.xyz/信息安全加密算法总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SherwinX">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="谢玮の技术Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/信息安全加密算法总结/" itemprop="url">信息安全加密算法总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-30T00:00:00+08:00">
                2018-04-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是信息安全"><a href="#什么是信息安全" class="headerlink" title="什么是信息安全?"></a>什么是信息安全?</h2><p>保证信息的保密性、可用性、完整性。</p>
<h2 id="为什么了解信息安全？"><a href="#为什么了解信息安全？" class="headerlink" title="为什么了解信息安全？"></a>为什么了解信息安全？</h2><p>有助于我们理解 https 、加密算法、数字签名、数字证书CA、SSL之间的关系。</p>
<p>另外，助于我们理解区块链的技术，源于信息安全。</p>
<p>区块链在信息安全上的的优势至少有三个方面：</p>
<ol>
<li>利用高冗余的分布式数据存储保障信息的数据完整性</li>
<li>利用密码学的相关原理进行数据验证，保证不可篡改</li>
<li>在权限管理方面，运用了多私钥规则进行访问权限控制</li>
</ol>
<h2 id="加密算法分类-密码学"><a href="#加密算法分类-密码学" class="headerlink" title="加密算法分类(密码学)"></a>加密算法分类(密码学)</h2><h3 id="单向加密"><a href="#单向加密" class="headerlink" title="单向加密"></a>单向加密</h3><p>单向加密是不可逆的，也就是只能加密，不能解密。通常用来传输类似用户名和密码，直接将加密后的数据提交到后台，因为后台不需要知道用户名和密码，可以直接将收到的加密后的数据存储到数据库。</p>
<h3 id="双向加密"><a href="#双向加密" class="headerlink" title="双向加密"></a>双向加密</h3><p>双向加密算法通常分为对称性加密算法和非对称性加密算法。</p>
<h4 id="对称性加密（单钥）"><a href="#对称性加密（单钥）" class="headerlink" title="对称性加密（单钥）"></a>对称性加密（单钥）</h4><p>对于对称性加密算法，信息接收双方都需事先知道密匙和加解密算法且其密匙是相同的，之后便是对数据进行加解密了。</p>
<h4 id="非对称性加密（双钥）"><a href="#非对称性加密（双钥）" class="headerlink" title="非对称性加密（双钥）"></a>非对称性加密（双钥）</h4><p>非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。</p>
<p>非对称加密算法实现机密信息交换的基本过程是：甲方生成一对密钥并将其中的一把作为公用密钥向其它方公开；得到该公用密钥的乙方使用该密钥对机密信息进行加密后再发送给甲方；甲方再用自己保存的另一把专用密钥对加密后的信息进行解密。</p>
<h2 id="单向加密应用"><a href="#单向加密应用" class="headerlink" title="单向加密应用"></a>单向加密应用</h2><h3 id="消息摘要（Message-Digest）"><a href="#消息摘要（Message-Digest）" class="headerlink" title="消息摘要（Message Digest）"></a>消息摘要（Message Digest）</h3><p>不需要密钥，严格意义来讲不算加密。</p>
<p>通过特定的Hash函数，生成固定长度的输出，即输入长度任意，输出长度固定。这个输出就是Hash值，也成为这个消息的消息摘要。</p>
<p>消息摘要保证了消息的完整性。如果发送者发送的消息，在传输过程中被恶意篡改，那么接收者收到消息后，用同样的摘要算法计算其摘要，如果新摘要与发送者原始摘要不同，那么接收者就知道消息被篡改了。这里有一个前提条件就是：接收者一定要事先知道消息的原始摘要。消息摘要不需要秘钥，不存在秘钥的保管和分发问题。</p>
<p>基本的单向加密算法:</p>
<ul>
<li>消息摘要算法MD系列 如MD5（128位）</li>
<li>SHA安全散列算法 如SHA1（160位)、SHA-256(256位)等</li>
<li>HMAC消息认证码算法，也称为MAC含有密钥的散列函数算法，融合MD、SHA，引入密钥。</li>
<li>BASE64编码算法不是加密算法，定义:Base64内容传送编码被设计用来把任意序列的8位字节描述为一种不易被人直接识别的形式。同时，BASE64和加密没什么关系。从转换成二进制后的角度上看，它依然是明码。加密需要保证，没有密钥的人无法解密信息，无法从密文中获得任何明文信息。</li>
</ul>
<p>JDK的Hash应用代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> HashEncryption;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.security.MessageDigest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.KeyGenerator;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.Mac;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.SecretKeySpec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.misc.BASE64Decoder;</span><br><span class="line"><span class="keyword">import</span> sun.misc.BASE64Encoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AllHashEncryption</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_SHA = <span class="string">"SHA"</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_MD5 = <span class="string">"MD5"</span>;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * MAC算法可选以下多种算法</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">	 * HmacMD5</span></span><br><span class="line"><span class="comment">	 * HmacSHA1</span></span><br><span class="line"><span class="comment">	 * HmacSHA256</span></span><br><span class="line"><span class="comment">	 * HmacSHA384</span></span><br><span class="line"><span class="comment">	 * HmacSHA512</span></span><br><span class="line"><span class="comment">	 * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_MAC = <span class="string">"HmacMD5"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * BASE64解密</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decryptBASE64(String key) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">new</span> BASE64Decoder()).decodeBuffer(key);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * BASE64加密</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encryptBASE64</span><span class="params">(<span class="keyword">byte</span>[] key)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">new</span> BASE64Encoder()).encodeBuffer(key);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * MD5加密</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] encryptMD5(<span class="keyword">byte</span>[] data) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">		MessageDigest md5 = MessageDigest.getInstance(KEY_MD5);</span><br><span class="line">		md5.update(data);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> md5.digest();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * SHA加密</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] encryptSHA(<span class="keyword">byte</span>[] data) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">		MessageDigest sha = MessageDigest.getInstance(KEY_SHA);</span><br><span class="line">		sha.update(data);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> sha.digest();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 初始化HMAC密钥</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">initMacKey</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		KeyGenerator keyGenerator = KeyGenerator.getInstance(KEY_MAC);</span><br><span class="line">		SecretKey secretKey = keyGenerator.generateKey();</span><br><span class="line">		<span class="keyword">return</span> encryptBASE64(secretKey.getEncoded());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * HMAC加密</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] encryptHMAC(<span class="keyword">byte</span>[] data, String key) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		SecretKey secretKey = <span class="keyword">new</span> SecretKeySpec(decryptBASE64(key), KEY_MAC);</span><br><span class="line">		Mac mac = Mac.getInstance(secretKey.getAlgorithm());</span><br><span class="line">		mac.init(secretKey);</span><br><span class="line">		<span class="keyword">return</span> mac.doFinal(data);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试类:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> HashEncryption;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashTest</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		String inputStr = <span class="string">"这是明文信息"</span>;</span><br><span class="line">		System.err.println(<span class="string">"原文:\n"</span> + inputStr);</span><br><span class="line">		<span class="keyword">byte</span>[] inputData = inputStr.getBytes();</span><br><span class="line">		String code = AllHashEncryption.encryptBASE64(inputData);</span><br><span class="line">		System.err.println(<span class="string">"BASE64加密后:\n"</span> + code);</span><br><span class="line">		<span class="keyword">byte</span>[] output = AllHashEncryption.decryptBASE64(code);</span><br><span class="line">		String outputStr = <span class="keyword">new</span> String(output);</span><br><span class="line">		System.err.println(<span class="string">"BASE64解密后:\n"</span> + outputStr);</span><br><span class="line">		<span class="comment">// 验证BASE64加密解密一致性</span></span><br><span class="line">		assertEquals(inputStr, outputStr);</span><br><span class="line">		<span class="comment">// 验证MD5对于同一内容加密是否一致</span></span><br><span class="line">		assertArrayEquals(AllHashEncryption.encryptMD5(inputData), AllHashEncryption</span><br><span class="line">				.encryptMD5(inputData));</span><br><span class="line">		<span class="comment">// 验证SHA对于同一内容加密是否一致</span></span><br><span class="line">		assertArrayEquals(AllHashEncryption.encryptSHA(inputData), AllHashEncryption</span><br><span class="line">				.encryptSHA(inputData));</span><br><span class="line">		String key = AllHashEncryption.initMacKey();</span><br><span class="line">		System.err.println(<span class="string">"Mac密钥:\n"</span> + key);</span><br><span class="line">		<span class="comment">// 验证HMAC对于同一内容，同一密钥加密是否一致</span></span><br><span class="line">		assertArrayEquals(AllHashEncryption.encryptHMAC(inputData, key), AllHashEncryption.encryptHMAC(</span><br><span class="line">				inputData, key));</span><br><span class="line">		BigInteger md5 = <span class="keyword">new</span> BigInteger(AllHashEncryption.encryptMD5(inputData));</span><br><span class="line">		System.err.println(<span class="string">"MD5:\n"</span> + md5.toString(<span class="number">16</span>));</span><br><span class="line">		BigInteger sha = <span class="keyword">new</span> BigInteger(AllHashEncryption.encryptSHA(inputData));</span><br><span class="line">		System.err.println(<span class="string">"SHA:\n"</span> + sha.toString(<span class="number">32</span>));</span><br><span class="line">		BigInteger mac = <span class="keyword">new</span> BigInteger(AllHashEncryption.encryptHMAC(inputData, inputStr));</span><br><span class="line">		System.err.println(<span class="string">"HMAC:\n"</span> + mac.toString(<span class="number">16</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="双向加密应用"><a href="#双向加密应用" class="headerlink" title="双向加密应用"></a>双向加密应用</h2><h3 id="对称加密算法-单钥"><a href="#对称加密算法-单钥" class="headerlink" title="对称加密算法(单钥)"></a>对称加密算法(单钥)</h3><p>常见单钥加密算法:</p>
<ul>
<li>DES 数据加密标准，速度较快，56位密钥，以现代计算能力，24小时内可被破解。</li>
<li>3DES 是基于DES，对一块数据用三个不同的密钥进行三次加密，强度更高；</li>
<li>AES (Advanced Encryption Standard) 进阶的加密标准，是新一代的加密算法标准，速度快，安全级别高，目前 AES 标准的一个实现是<br>Rijndael 算法。</li>
</ul>
<p>DES代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.security.SecureRandom;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.DESKeySpec;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKeyFactory;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> DES加密介绍</span></span><br><span class="line"><span class="comment">      DES是一种对称加密算法，所谓对称加密算法即：加密和解密使用相同密钥的算法。DES加密算法出自IBM的研究，</span></span><br><span class="line"><span class="comment"> 后来被美国政府正式采用，之后开始广泛流传，但是近些年使用越来越少，因为DES使用56位密钥，以现代计算能力，</span></span><br><span class="line"><span class="comment"> 24小时内即可被破解。虽然如此，在某些简单应用中，我们还是可以使用DES加密算法，本文简单讲解DES的JAVA实现</span></span><br><span class="line"><span class="comment"> 。</span></span><br><span class="line"><span class="comment"> 注意：DES加密和解密过程中，密钥长度都必须是8的倍数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DES</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DES</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//测试</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">         <span class="comment">//待加密内容</span></span><br><span class="line">         String str = <span class="string">"sherwinxie"</span>;</span><br><span class="line">         <span class="comment">//密码，长度要是8的倍数</span></span><br><span class="line">         String password = <span class="string">"01234567"</span>;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">byte</span>[] result = DES.encrypt(str.getBytes(),password);</span><br><span class="line">         System.out.println(<span class="string">"加密后："</span>+<span class="keyword">new</span> String(result));</span><br><span class="line">         <span class="comment">//直接将如上内容解密</span></span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">                 <span class="keyword">byte</span>[] decryResult = DES.decrypt(result, password);</span><br><span class="line">                 System.out.println(<span class="string">"解密后："</span>+<span class="keyword">new</span> String(decryResult));</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Exception e1) &#123;</span><br><span class="line">                 e1.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> datasource byte[]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> password String</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> byte[]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">byte</span>[] encrypt(<span class="keyword">byte</span>[] datasource, String password) &#123;            </span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">        SecureRandom random = <span class="keyword">new</span> SecureRandom();</span><br><span class="line">        DESKeySpec desKey = <span class="keyword">new</span> DESKeySpec(password.getBytes());</span><br><span class="line">        <span class="comment">//创建一个密匙工厂，然后用它把DESKeySpec转换成</span></span><br><span class="line">        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(<span class="string">"DES"</span>);</span><br><span class="line">        SecretKey securekey = keyFactory.generateSecret(desKey);</span><br><span class="line">        <span class="comment">//Cipher对象实际完成加密操作</span></span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">"DES"</span>);</span><br><span class="line">        <span class="comment">//用密匙初始化Cipher对象,ENCRYPT_MODE用于将 Cipher 初始化为加密模式的常量</span></span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, securekey, random);</span><br><span class="line">        <span class="comment">//现在，获取数据并加密</span></span><br><span class="line">        <span class="comment">//正式执行加密操作</span></span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(datasource); <span class="comment">//按单部分操作加密或解密数据，或者结束一个多部分操作</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(Throwable e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> src byte[]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> password String</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> byte[]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decrypt(<span class="keyword">byte</span>[] src, String password) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="comment">// DES算法要求有一个可信任的随机数源</span></span><br><span class="line">            SecureRandom random = <span class="keyword">new</span> SecureRandom();</span><br><span class="line">            <span class="comment">// 创建一个DESKeySpec对象</span></span><br><span class="line">            DESKeySpec desKey = <span class="keyword">new</span> DESKeySpec(password.getBytes());</span><br><span class="line">            <span class="comment">// 创建一个密匙工厂</span></span><br><span class="line">            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(<span class="string">"DES"</span>);<span class="comment">//返回实现指定转换的 Cipher 对象</span></span><br><span class="line">            <span class="comment">// 将DESKeySpec对象转换成SecretKey对象</span></span><br><span class="line">            SecretKey securekey = keyFactory.generateSecret(desKey);</span><br><span class="line">            <span class="comment">// Cipher对象实际完成解密操作</span></span><br><span class="line">            Cipher cipher = Cipher.getInstance(<span class="string">"DES"</span>);</span><br><span class="line">            <span class="comment">// 用密匙初始化Cipher对象</span></span><br><span class="line">            cipher.init(Cipher.DECRYPT_MODE, securekey, random);</span><br><span class="line">            <span class="comment">// 真正开始解密操作</span></span><br><span class="line">            <span class="keyword">return</span> cipher.doFinal(src);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="非对称加密算法-公钥私钥"><a href="#非对称加密算法-公钥私钥" class="headerlink" title="非对称加密算法(公钥私钥)"></a>非对称加密算法(公钥私钥)</h3><ul>
<li>RSA(算法的名字以发明者的名字命名：Ron Rivest, AdiShamir 和Leonard Adleman)</li>
<li>ECC(Elliptic Curves Cryptography，椭圆曲线密码编码学)</li>
<li>DSA(Digital Signature Algorithm，数字签名)</li>
<li>DES(Data Encryption Standard，数据加密算法)</li>
</ul>
<h4 id="RSA原理"><a href="#RSA原理" class="headerlink" title="RSA原理:"></a>RSA原理:</h4><p>RSA算法大体可以分为三个部分：生成密钥对（公钥私钥）、加密、解密。<br>其获取步骤为：</p>
<ol>
<li><p>取两个大素数p和q (保密)；</p>
</li>
<li><p>计算 n=p<em>q (公开), 欧拉函数φ(n)=(p-1)</em>(q-1) 即与n互素的个数(保密)；</p>
</li>
<li><p>随机选取整数e，满足最大公约数gcd(e, φ(n))=1 （e与φ(n)互素）(公开)；</p>
</li>
<li><p>计算私钥元素 d 满足 d * e ≡ 1 (mod φ(n)) (保密)；</p>
</li>
<li><p>｛e，n｝为公钥，｛d，n｝为私钥，也可以用｛e，d｝表示密钥对</p>
</li>
<li>公钥加密时c = x^e mod n ；私钥解密时x = c^d mod n</li>
<li>私钥签名时c = x^d mod n ；公钥验证时x = c^e mod n</li>
</ol>
<h4 id="RSA简单案例："><a href="#RSA简单案例：" class="headerlink" title="RSA简单案例："></a>RSA简单案例：</h4><p>在RSA公钥体制中,单向函数的构造基于大整数n因数分解的困难 ,因而n的两个因数p与q都应取大素数。为便于理解,我们选取两个较小的素数来说明该体制的实施。</p>
<p>案例：</p>
<ol>
<li><p>小谢要给小红发信息，那么小红首先需要生成两个素数p和q。</p>
</li>
<li><p>为了计算简单，我们假设p = 17和q = 3，实际应用中p和q往往长达数百上千位。 计算n=17∗3=51 ，而欧拉函数φ(n)=(17−1)(3−1)=32即与n互素的个数</p>
</li>
<li><p>选取和欧拉函数φ(n)32互质的3作为公钥中的e。那么公钥就是(3, 51)。 </p>
</li>
<li><p>然后计算3在模32下的数论倒数d。使用扩展欧几里德算法求得d = 11。 </p>
</li>
<li><p>验证一下，d ∗ e=11 ∗ 3=33，而33 mod 32=1，所以11是3在模32下的数论倒数即逆元。私钥为(11, 51)。 </p>
</li>
<li><p>小红通过公共信道把公钥(3, 51)发给小谢。<br>假设小谢要发给小红的原文信息是2，对它进行加密，也就是计算23 mod 51=8。得到密文C = 8。 </p>
</li>
<li><p>小谢将密文8发送给小红。小红收到后，进行解密运算811 mod 51=2。得到原文2。</p>
</li>
</ol>
<p>RSA代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">import</span> java.security.interfaces.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.math.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RSADemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  生成密钥并保存的函数</span></span><br><span class="line"><span class="comment">     *  将公钥和私钥以文件流的形式保存在当前文件目录下生成密钥并保存函数</span></span><br><span class="line"><span class="comment">     *  将公钥和私钥以文件流的形式保存在当前文件目录下</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">generateKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            KeyPairGenerator kpg = KeyPairGenerator.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">            kpg.initialize(<span class="number">1024</span>);<span class="comment">//RSA的加密位设为1024位</span></span><br><span class="line">            KeyPair kp = kpg.genKeyPair();</span><br><span class="line">            PublicKey pbkey = kp.getPublic();</span><br><span class="line">            PrivateKey prkey = kp.getPrivate();</span><br><span class="line">            <span class="comment">// 保存公钥  </span></span><br><span class="line">            FileOutputStream f1 = <span class="keyword">new</span> FileOutputStream(<span class="string">"pubkey.txt"</span>);</span><br><span class="line">            ObjectOutputStream b1 = <span class="keyword">new</span> ObjectOutputStream(f1);</span><br><span class="line">            b1.writeObject(pbkey);</span><br><span class="line">            <span class="comment">// 保存私钥  </span></span><br><span class="line">            FileOutputStream f2 = <span class="keyword">new</span> FileOutputStream(<span class="string">"privatekey.txt"</span>);</span><br><span class="line">            ObjectOutputStream b2 = <span class="keyword">new</span> ObjectOutputStream(f2);</span><br><span class="line">            b2.writeObject(prkey);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * encrypt()加密函数，以BigInteger类型储存便于提取出公钥中的（e，N）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">encrypt</span><span class="params">(String msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String content = msg;</span><br><span class="line">        <span class="comment">// 获取公钥及参数e,n</span></span><br><span class="line">        FileInputStream f = <span class="keyword">new</span> FileInputStream(<span class="string">"pubkey.txt"</span>);</span><br><span class="line">        ObjectInputStream b = <span class="keyword">new</span> ObjectInputStream(f);</span><br><span class="line">        RSAPublicKey pbk = (RSAPublicKey) b.readObject();</span><br><span class="line">        BigInteger e = pbk.getPublicExponent();<span class="comment">//获得公钥的指数</span></span><br><span class="line">        BigInteger n = pbk.getModulus();</span><br><span class="line">        System.out.println(<span class="string">"公钥 e= "</span> + e+<span class="string">"\n"</span>+<span class="string">"n= "</span> + n);</span><br><span class="line">        <span class="comment">// 获取明文m</span></span><br><span class="line">        <span class="keyword">byte</span> ptext[] = content.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line">        BigInteger m = <span class="keyword">new</span> BigInteger(ptext);</span><br><span class="line">        <span class="comment">// 计算密文c</span></span><br><span class="line">        BigInteger c = m.modPow(e, n);</span><br><span class="line">        System.out.println(<span class="string">"加密后为： "</span> + c);</span><br><span class="line">        <span class="comment">// 保存密文</span></span><br><span class="line">        String cs = c.toString();</span><br><span class="line">        BufferedWriter out =</span><br><span class="line">                <span class="keyword">new</span> BufferedWriter(</span><br><span class="line">                        <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">"encrypt.txt"</span>)));</span><br><span class="line">        out.write(cs, <span class="number">0</span>, cs.length());</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * decrypt()解密函数，以BigInteger类型储存便于提取出公钥中的（d，N）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decrypt</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 读取密文  </span></span><br><span class="line">        BufferedReader in =</span><br><span class="line">                <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                        <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">"encrypt.txt"</span>)));</span><br><span class="line"></span><br><span class="line">        String ctext = in.readLine();</span><br><span class="line">        BigInteger c = <span class="keyword">new</span> BigInteger(ctext);</span><br><span class="line">        <span class="comment">// 读取私钥  </span></span><br><span class="line">        FileInputStream f = <span class="keyword">new</span> FileInputStream(<span class="string">"privatekey.txt"</span>);</span><br><span class="line">        ObjectInputStream b = <span class="keyword">new</span> ObjectInputStream(f);</span><br><span class="line">        RSAPrivateKey prk = (RSAPrivateKey) b.readObject();</span><br><span class="line">        BigInteger d = prk.getPrivateExponent();</span><br><span class="line">        <span class="comment">// 获取私钥参数及解密  </span></span><br><span class="line">        BigInteger n = prk.getModulus();</span><br><span class="line">        System.out.println(<span class="string">"私钥"</span>+<span class="string">"d= "</span>+ d+<span class="string">"\n"</span>+<span class="string">" n= "</span> + n);</span><br><span class="line">        BigInteger m = c.modPow(d, n);</span><br><span class="line">        <span class="comment">// 显示解密结果  </span></span><br><span class="line">        System.out.println(<span class="string">"解密后大整数为： "</span> + m);</span><br><span class="line">        <span class="keyword">byte</span>[] mContent = m.toByteArray();</span><br><span class="line">        String s = <span class="keyword">new</span> String(mContent,<span class="string">"UTF-8"</span>);</span><br><span class="line">        System.out.println(<span class="string">"\n解密后的明文:"</span> + s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String contentTest = <span class="string">"RSA算法加密的原文加中文标点符号，。~￥ --SherwinXie"</span>;</span><br><span class="line">            generateKey();</span><br><span class="line">            encrypt(contentTest);</span><br><span class="line">            decrypt();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><p>数字签名：把数字证书的hash值（指纹）用私钥加密就得到数字签名，其作用是保证信息的完整性；</p>
<h2 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h2><p>数字证书：是通信确定身份的一种电子证书，该电子证书一般是有权威的CA机构颁发，如果出现问题，颁发机构会负全部责任。数字证书确认通信服务器的身份同时还公布公钥；</p>
<h2 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h2><p>安全套接字层，这是一种在可靠协议之上（如：TCP）的协议层，保证身份认证和加密传输；SSL协议位于TCP/IP协议与各种应用层协议之间，为数据通讯提供安全支持。</p>
<p>SSL协议的优势在于它与应用层协议是独立无关的。高层的应用层协议 (例如：Http、FTP、Telnet等等 ) 能透明的建立于SSL协议之上。SSL协议在应用层协议通信之前就已完成数据加密、通信密钥的协商和服务器的认证等工作。在此之后应用层协议所传送的数据都会被加密，从而保证通信的私密性。</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ul>
<li><p>公钥和私钥是成对的，它们互相解密。<br>公钥加密，私钥解密。<br>私钥数字签名，公钥验证。</p>
</li>
<li><p>数字签名是数字证书的hash值加密的结果；</p>
</li>
<li>SSL 用到数字证书报证加密机制（如：RAS）公钥的发布、通讯双方的身份验证、信息完整性；</li>
<li>https、http是SSL携带的数据。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sherwinxie.xyz/工厂模式总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SherwinX">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="谢玮の技术Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/工厂模式总结/" itemprop="url">工厂模式总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-29T00:00:00+08:00">
                2018-04-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="工厂模式是什么"><a href="#工厂模式是什么" class="headerlink" title="工厂模式是什么?"></a>工厂模式是什么?</h3><p>工厂模式主要是为创建对象提供了过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。 </p>
<h5 id="GOF在《设计模式》一书中将工厂模式分为两大类："><a href="#GOF在《设计模式》一书中将工厂模式分为两大类：" class="headerlink" title="GOF在《设计模式》一书中将工厂模式分为两大类："></a>GOF在《设计模式》一书中将工厂模式分为两大类：</h5><ul>
<li>工厂方法模式（Factory Method）</li>
<li>抽象工厂模式（Abstract Factory）。</li>
</ul>
<p>将简单工厂模式（Simple Factory）看为工厂方法模式的一种特例，两者归为一类。</p>
<h4 id="工厂模式的常见类型："><a href="#工厂模式的常见类型：" class="headerlink" title="工厂模式的常见类型："></a>工厂模式的常见类型：</h4><h5 id="1）简单工厂模式（Simple-Factory）"><a href="#1）简单工厂模式（Simple-Factory）" class="headerlink" title="1）简单工厂模式（Simple Factory）"></a>1）简单工厂模式（Simple Factory）</h5><p>简单工厂模式是属于创建型模式，又叫做静态工厂方法（Static Factory Method）模式，但不属于23种GOF设计模式之一。</p>
<p>简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式，可以理解为是不同工厂模式的一个特殊实现。</p>
<p>这个缺点是每添一个对象，就需要对简单工厂进行修改（尽管不是删代码，仅仅是添一个switch case，但仍然违背了“不改代码”的开闭原则，不利于拓展）</p>
<p>比如下图中的鼠标工厂和Mouse接口，专业生产鼠标，给参数0，生产戴尔鼠标，给参数1，生产惠普鼠标。<br><img src="https://ws2.sinaimg.cn/large/006tKfTcly1frfe6e6lrlj30k0078aaa.jpg" alt="simple"></p>
<h5 id="2）工厂方法模式（Factory-Method）"><a href="#2）工厂方法模式（Factory-Method）" class="headerlink" title="2）工厂方法模式（Factory Method）"></a>2）工厂方法模式（Factory Method）</h5><p>本质就是代替new创建对象，每种产品由一种工厂来创建，一个工厂保存一个new，工厂方法模式,其原理就是对简单工厂也进行抽象。</p>
<p>UML图解:</p>
<p>生产哪种鼠标不再由参数决定，而是创建鼠标工厂时，由戴尔鼠标工厂创建。 后续直接调用具体鼠标工厂.生产鼠标()即可<br><img src="https://ws4.sinaimg.cn/large/006tKfTcly1frfe7amg36j30k007t0t5.jpg" alt="fac"></p>
<h5 id="3）抽象工厂模式（Abstract-Factory）"><a href="#3）抽象工厂模式（Abstract-Factory）" class="headerlink" title="3）抽象工厂模式（Abstract Factory）"></a>3）抽象工厂模式（Abstract Factory）</h5><p>一个抽象工厂类，多个产品抽象类或接口（Mouse，Keybo），每个抽象产品类可以派生出多个具体产品类。   </p>
<p>一个抽象工厂类，可以派生出多个具体工厂类。每个具体工厂类可以创建多个具体产品类的实例。</p>
<p>和2)工厂方法模式的区别：</p>
<ul>
<li>工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。  </li>
<li>工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个。</li>
</ul>
<p>UML图解:</p>
<p>抽象工厂模式也就是不仅生产鼠标，还可以生产键盘。也就是PC厂商是个父类，有生产鼠标，生产键盘两个接口。<br><img src="https://ws2.sinaimg.cn/large/006tKfTcly1frfe8lpxjdj30k00bjt9i.jpg" alt="ab"></p>
<p>在抽象工厂模式中，假设我们需要再增加一个工厂，符合开闭原则。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1frffgi5uv4j30k009nmy4.jpg" alt="add"></p>
<p>添加一个产品同理。但需要注意的是如添加一个音响，在具体品牌工厂中填写对应创建该音响产品的方法。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sherwinxie.xyz/单例模式总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SherwinX">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="谢玮の技术Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/单例模式总结/" itemprop="url">单例模式总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-29T00:00:00+08:00">
                2018-04-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="单例模式是什么？"><a href="#单例模式是什么？" class="headerlink" title="单例模式是什么？"></a>单例模式是什么？</h2><p>　作为对象的创建模式，单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。这个类称为单例类。
　</p>
<p>单例模式的特点：</p>
<ul>
<li>单例类只能有一个实例。 将该类的构造方法定义为私有方法，这样其他处的代码就无法通过调用该类的构造方法来实例化该类的对象。</li>
<li>单例类必须给所有其他对象提供这一实例。<br>一般由该类自己负责创建实例，并提供一个静态方法作为该实例的访问点。</li>
</ul>
<h2 id="为何需要单例模式"><a href="#为何需要单例模式" class="headerlink" title="为何需要单例模式?"></a>为何需要单例模式?</h2><p>对于系统中的某些类来说，只有一个实例很重要，例如，一个系统只能有一个窗口管理器或文件系统；一个系统只能有一个计时工具或ID序号生成器;网站的计数器，一般也是采用单例模式实现，否则难以同步；</p>
<p>并发多线程的线程池的设计一般也是采用单例模式，这是由于线程池要方便对池中的线程进行控制。 </p>
<h2 id="单例模式的使用"><a href="#单例模式的使用" class="headerlink" title="单例模式的使用"></a>单例模式的使用</h2><h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h4><p>饿汉式是典型的空间换时间，当类装载的时候就会创建类的实例，不管你用不用，先创建出来，然后每次调用的时候，就不需要再判断，节省了运行时间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EagerSingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> EagerSingleton instance = <span class="keyword">new</span> EagerSingleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EagerSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态工厂方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EagerSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优点：实现简单，无线程同步问题</p>
<p>缺点：在类装载时完成实例化。若该实例一直未被使用，则会造成资源浪费</p>
<h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h4><p>懒汉式是典型的时间换空间,就是每次获取实例都会进行判断，看是否需要创建实例，浪费判断的时间。当然，如果一直没有人使用的话，那就不会创建实例，则节约内存开销。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 懒汉式对静态工厂方法使用了synchronized同步化，以处理多线程环境。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于懒汉式的实现是线程安全的，这样会降低整个访问的速度，而且每次都要判断。那么更好的实现就引进了双重检查加锁。</p>
<h3 id="双重检查加锁"><a href="#双重检查加锁" class="headerlink" title="双重检查加锁"></a>双重检查加锁</h3><p>双重检查加锁机制并不需要每次进入getInstance方法都需要同步，而是先不同步，进入方法后，先检查实例是否存在，如果不存在才进行下面的同步块，这是第一重检查，进入同步块过后，再次检查实例是否存在，如果不存在，就在同步的情况下创建一个实例，这是第二重检查。这样一来，就只需要同步一次了，从而减少了多次在同步情况下进行判断所浪费的时间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//先检查实例是否存在，如果不存在才进入下面的同步块</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//同步块，线程安全的创建实例</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">//再次检查实例是否存在，如果不存在才真正的创建实例</span></span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“双重检查加锁”机制的实现会使用关键字volatile(JDK1.5以上版本)，它的意思是：被volatile修饰的变量的值，将不会被本地线程缓存，所有对该变量的读写都是直接操作共享内存，从而确保多个线程能正确的处理该变量。</p>
<p>这种实现方式既可以实现线程安全地创建实例，而又不会对性能造成太大的影响。它只是第一次创建实例的时候同步，以后就不需要同步了，从而加快了运行速度。</p>
<h3 id="懒汉延迟加载模式-Lazy-initialization-holder-class"><a href="#懒汉延迟加载模式-Lazy-initialization-holder-class" class="headerlink" title="懒汉延迟加载模式(Lazy initialization holder class)"></a>懒汉延迟加载模式(Lazy initialization holder class)</h3><p>这个模式综合使用了Java的类级内部类和多线程缺省同步锁的知识，很巧妙地同时实现了延迟加载和线程安全。</p>
<h5 id="类级内部类知识"><a href="#类级内部类知识" class="headerlink" title="类级内部类知识"></a>类级内部类知识</h5><ul>
<li>类级内部类指的是，有static修饰的成员式内部类。如果没有static修饰的成员式内部类被称为对象级内部类。</li>
<li>类级内部类相当于其外部类的static成分，它的对象与外部类对象间不存在依赖关系，因此可直接创建。而对象级内部类的实例，是绑定在外部对象实例中的。</li>
<li>类级内部类中，可以定义静态的方法。在静态方法中只能够引用外部类中的静态成员方法或者成员变量。</li>
<li>类级内部类相当于其外部类的成员，只有在第一次被使用的时候才被会装载。</li>
</ul>
<h5 id="多线程缺省同步锁的知识"><a href="#多线程缺省同步锁的知识" class="headerlink" title="多线程缺省同步锁的知识"></a>多线程缺省同步锁的知识</h5><p>大家都知道，在多线程开发中，为了解决并发问题，主要是通过使用synchronized来加互斥锁进行同步控制。但是在某些情况中，JVM已经隐含地为您执行了同步，这些情况下就不用自己再来进行同步控制了。这些情况包括：</p>
<ul>
<li>1.由静态初始化器（在静态字段上或static{}块中的初始化器）初始化数据时</li>
<li>2.访问final字段时</li>
<li>3.在创建线程之前创建对象时</li>
<li>4.线程可以看见它将要处理的对象时</li>
</ul>
<p>以下代码采用类级内部类，在这个类级内部类里面去创建对象实例。这样一来，只要不使用到这个类级内部类，那就不会创建对象实例，从而同时实现延迟加载和线程安全。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *    类级的内部类，也就是静态的成员式内部类，该内部类的实例与外部类的实例</span></span><br><span class="line"><span class="comment">     *    没有绑定关系，而且只有被调用到时才会装载，从而实现了延迟加载。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 静态初始化器，由JVM来保证线程安全</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="单例和枚举"><a href="#单例和枚举" class="headerlink" title="单例和枚举"></a>单例和枚举</h3><p>单元素的枚举类型已经成为实现Singleton的最佳方法，用枚举来实现单例非常简单，只需要编写一个包含单个元素的枚举类型即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">  INSTANCE; <span class="comment">//定义一个枚举的元素，它就代表了Singleton的一个实例。</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//单例可以有自定义的操作方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whatSoEverMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//功能处理</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 该方法非必须，只是为了保证与其它方案一样使用静态方法得到实例</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优点：枚举本身是线程安全的，且能防止通过反射和反序列化创建多实例，是更简洁、高效、安全的实现单例的方式。</p>
<p>缺点：使用的是枚举，而非类。 </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sherwinxie.xyz/适配器模式总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SherwinX">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="谢玮の技术Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/适配器模式总结/" itemprop="url">适配器模式总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-28T00:00:00+08:00">
                2018-04-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是适配器模式？"><a href="#什么是适配器模式？" class="headerlink" title="什么是适配器模式？"></a>什么是适配器模式？</h2><h3 id="适配器模式（Adapter-Pattern）"><a href="#适配器模式（Adapter-Pattern）" class="headerlink" title="适配器模式（Adapter Pattern）"></a>适配器模式（Adapter Pattern）</h3><p>定义：将一个类的接口转换成客户(需要调用我们代码的对象)希望的另一个目标接口(Target)。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类通过适配器可以一起工作。</p>
<p>这种类型的设计模式属于结构型模式，适配器可以结合了两个独立接口的功能。</p>
<p>举个现实的例子，当我们给手机充电时，由于手机充电口是5V，而插座提供的是220V交流电，因此我们通常需要使用充电器将220V交流电转换成可供手机充电用的5V直流电，这个充电器就是一个适配器，220V是一个接口的方法，5V充电方法是客户（即手机）希望的另一个目标接口的扩展方法。</p>
<h3 id="适配器模式有三种"><a href="#适配器模式有三种" class="headerlink" title="适配器模式有三种:"></a>适配器模式有三种:</h3><ul>
<li>类适配器-通过Java单继承，用于单一源的适配，由于它的源单一，代码实现不用写选择逻辑，很清晰。</li>
<li>对象适配器-通过使用Java组合和适配器包含源对象。可用于多源的适配，弥补了类适配模式的不足，使得原本用类适配模式需要写很多适配器的情况不复存在，弱点是，由于源的数目可以较多，所以具体的实现条件选择分支比较多，不太清晰。</li>
<li>默认适配器模式(Default Adapter Pattern) 当你实现一个接口却只想重写其部分方法，通过抽象类当适配器实现。</li>
</ul>
<h3 id="适配器的三个角色"><a href="#适配器的三个角色" class="headerlink" title="适配器的三个角色"></a>适配器的三个角色</h3><ul>
<li>Source源角色（Adaptee），现有的功能。</li>
<li>Destination目标角色（Target），目标接口，要添加的功能。</li>
<li>Adapter适配器角色（Adapter），核心是实现Target接口, 继承或组合Adaptee(对应类适配器或对象适配器)，协调Source和Destination，使两者能够协同工作。</li>
</ul>
<h3 id="适配器模式应用场景"><a href="#适配器模式应用场景" class="headerlink" title="适配器模式应用场景"></a>适配器模式应用场景</h3><p>在开发中，也就是系统的数据和行为都正确，但接口不相符时，我们应该考虑用适配器，目的是使控制范围之外的一个原有对象与某个接口匹配。适配器模式主要应用于希望复用一些现存的类，但是接口又与复用环境要求不一致的情况。比如在需要对早期代码复用一些功能等应用上很有实际价值。适用场景大致包含三类：</p>
<ol>
<li><p>已经存在的类的接口不符合我们的需求；这时创建一个适配器就能间接去访问这个类中的方法。</p>
</li>
<li><p>我们有一个类，想将其设计为可复用的类（可被多处访问），我们可以创建适配器来将这个类来适配协同工作其他没有提供合适接口的类。</p>
</li>
<li><p>想要使用接口中的某个或某些方法，但是接口中有太多方法，我们要使用时必须实现接口并实现其中的所有方法，可以使用抽象类来实现接口，并不对方法进行实现（仅置空），然后我们再继承这个抽象类来通过重写想用的方法的方式来实现。</p>
</li>
</ol>
<h2 id="适配器模式应用"><a href="#适配器模式应用" class="headerlink" title="适配器模式应用"></a>适配器模式应用</h2><p>我们需要一个类A（源角色）来实现接口B（目标角色），但是类A并没有实现接口B中的所有方法，而类A是不让改动的，这时我们可以创建一个类C（适配器角色），它继承类A并实现接口B，这个类C就是一个适配器。</p>
<h4 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h4><p>源角色:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AI</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 人工智能AI现在只能说英语 省略setter,getter方法..</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayEnglish</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"AI can say English!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>目标角色: 让人工智能说中文和法语<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target_AI</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sayEnglish</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sayFrench</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sayChinese</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>类 适配器角色:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扩展源角色AI类，实现目标角色，从而使得目标角</span></span><br><span class="line"><span class="comment"> * 接口扩展时，不用改动源角色，只要改动其适配器 </span></span><br><span class="line"><span class="comment"> * 类适配器,因为继承了Person,而Java中只能单继承,所以这个适配器只为person这一个源角色类服务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter_AI</span> <span class="keyword">extends</span> <span class="title">AI</span> <span class="keyword">implements</span> <span class="title">Target_AI</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayFrench</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"AI can say French!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayChinese</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"AI can say Chinese!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>客户端测试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Target_AI ai = <span class="keyword">new</span> Adapter_AI();</span><br><span class="line"></span><br><span class="line">    ai.sayEnglish();</span><br><span class="line">    ai.sayChinese();<span class="comment">//AI也可以说汉语了Mandarin</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h4><p>测试类同上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对象适配器,与类适配器不同的是:对象适配器可以适配多个源到目标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter_AI</span> <span class="keyword">implements</span> <span class="title">Target_AI</span></span>&#123;  <span class="comment">//仅仅实现目标接口</span></span><br><span class="line">  <span class="keyword">private</span> AI ai;</span><br><span class="line">  <span class="comment">//在构造函数中将Adaptee类Person传递进来</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Adapter_AI</span><span class="params">(AI ai)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.ai = ai;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//实现目标接口中的sayEnglish()--调用Adaptee中的sayEnglish()</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayEnglish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.ai.sayEnglish();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//实现接口中的其它方法</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayFrench</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"ai can say French!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayChinese</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"ai can say Chinese!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="默认适配器"><a href="#默认适配器" class="headerlink" title="默认适配器"></a>默认适配器</h4><p>这种模式的核心在于：当你想实现一个接口但又不想实现所有接口方法，只想去实现一部分方法时，就用中默认的适配器模式，他的方法是在接口和具体实现类中添加一个抽象类，而用抽象类去空实现目标接口的所有方法。而具体的实现类只需要覆盖其需要完成的方法即可。</p>
<p>Skill接口:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Skill</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">speakEnglish</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">speakFrench</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">speakChinese</span><span class="params">()</span></span>;  </span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Adapter抽象类空实现方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">Skill</span></span>&#123; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speakChinese</span><span class="params">()</span> </span>&#123;&#125; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speakEnglish</span><span class="params">()</span> </span>&#123;&#125;  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speakFrench</span><span class="params">()</span> </span>&#123;&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>具体实现类通过抽象类适配器重写部分方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client_AI</span> <span class="keyword">extends</span> <span class="title">Adapter</span></span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speakChinese</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"I just speak Chinese!"</span>) </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="适配器模式优缺点"><a href="#适配器模式优缺点" class="headerlink" title="适配器模式优缺点"></a>适配器模式优缺点</h2><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ol>
<li>可以让任何两个没有关联的类一起运行。   </li>
<li>提高了类的复用。    </li>
<li>增加了类的透明度。 </li>
<li>灵活性好。 </li>
</ol>
<p>适配器模式也是一种包装模式，它与装饰模式同样具有包装的功能，此外，对象适配器模式还具有委托的意思。总的来说，适配器模式属于补偿模式，专用来在系统后期扩展、修改时使用。</p>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul>
<li>过多的使用适配器，会让系统非常零乱，不易整体进行把握。<br>比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可以说Source（源）的存在形式决定了适配器的名字：</p>
<ul>
<li>类适配器就是继承(is a)Source类</li>
<li>对象适配器就是持有（has a）Source类</li>
<li>默认适配器就是实现Source接口的部分方法。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sherwinxie.xyz/常见排序算法整理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SherwinX">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="谢玮の技术Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/常见排序算法整理/" itemprop="url">常见排序算法整理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-17T00:00:00+08:00">
                2018-04-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="常见排序算法整理"><a href="#常见排序算法整理" class="headerlink" title="常见排序算法整理"></a>常见排序算法整理</h1><table>
<thead>
<tr>
<th>类别</th>
<th>排序方法</th>
<th>时间复杂度(平均)</th>
<th>时间复杂度(最好)</th>
<th>时间复杂度(最坏)</th>
<th>空间复杂度</th>
<th>稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入排序</td>
<td>直接插入</td>
<td>O(n<sup>2</sup>)</td>
<td>O(n)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>同上</td>
<td>希尔排序</td>
<td>O(n<sup>1.3</sup>)</td>
<td>O(n)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>选择排序</td>
<td>直接选择</td>
<td>O(n<sup>2</sup>)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>同上</td>
<td>堆排序</td>
<td>O(nlog<sub>2</sub>n)</td>
<td>O(nlog<sub>2</sub>n)</td>
<td>O(nlog<sub>2</sub>n)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>交换排序</td>
<td>冒泡排序</td>
<td>O(n<sup>2</sup>)</td>
<td>O(n)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>同上</td>
<td>快速排序</td>
<td>O(nlog<sub>2</sub>n)</td>
<td>O(nlog<sub>2</sub>n)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(nlog<sub>2</sub>n)</td>
<td>不稳定</td>
</tr>
<tr>
<td>分治排序</td>
<td>归并排序</td>
<td>O(nlog<sub>2</sub>n)</td>
<td>O(nlog<sub>2</sub>n)</td>
<td>O(nlog<sub>2</sub>n)</td>
<td>O(n)</td>
<td>稳定</td>
</tr>
<tr>
<td>分类排序</td>
<td>基数排序</td>
<td>O(d(n+r))</td>
<td>O(d(n+r))</td>
<td>O(d(n+r))</td>
<td>O(n+r)</td>
<td>稳定</td>
</tr>
</tbody>
</table>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1fr21pod6v1j30zq0hmk4u.jpg" alt="image"></p>
<h2 id="关于Swap交换的空间优化"><a href="#关于Swap交换的空间优化" class="headerlink" title="关于Swap交换的空间优化"></a>关于Swap交换的空间优化</h2><p>节省了空间，也必然造成时间（运算）上的开销，就像时间和空间复杂度的反比关系，其实也不矛盾，如果你了解一些广义相对论的结论话，你会发现时间和空间是一回事。就像爱因斯坦所说“时空告诉物质如何运动； 物质告诉时空如何弯曲”。</p>
<p>不使用中间变量的两种方法: 加减运算交换 和 异或运算交换<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swapWithoutTempVar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line">	System.out.println(<span class="string">"before swap：a="</span> + a + <span class="string">", b="</span> + b);</span><br><span class="line">	<span class="comment">//加减运算交换</span></span><br><span class="line">	<span class="keyword">if</span> (a != b) &#123;</span><br><span class="line">		a = a + b;</span><br><span class="line">		b = a - b;</span><br><span class="line">		a = a - b;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(<span class="string">"after swap：a="</span> + a + <span class="string">", b="</span> + b);</span><br><span class="line">	<span class="comment">//异或运算交换</span></span><br><span class="line">	<span class="keyword">if</span> (a != b) &#123;</span><br><span class="line">		a = a ^ b;</span><br><span class="line">		b = a ^ b;</span><br><span class="line">		a = a ^ b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="交换排序-冒泡、快排"><a href="#交换排序-冒泡、快排" class="headerlink" title="交换排序[冒泡、快排]"></a>交换排序[冒泡、快排]</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>i表示比较N趟 j表示每趟里的次数 大的数往<br>for(j=0, j&lt;0-N1 -i;j++) 每趟都比较一对数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//array[]为待排序数组，n:数组长度,i:趟,j:次，temp:临时变量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> array[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, k;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">				k = array[j];</span><br><span class="line">				array[j] = array[j + <span class="number">1</span>];</span><br><span class="line">				array[j + <span class="number">1</span>] = k;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>选一个pivot（哨兵），经过划分后， 小的数都在哨兵的左边，大的数都在哨兵右边，继续对左右两边选出哨兵，依次递归划分下去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">qucikSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//partition arr[left ... pivot ...  right]</span></span><br><span class="line">	<span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> pivot = arr[left];<span class="comment">//pivot初值为arr[0]</span></span><br><span class="line">	<span class="keyword">int</span> i = left, j = right;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//j左移 比p大就--  找到一个比p小的索引  和i交换  i和j索引相等时退出</span></span><br><span class="line">		<span class="keyword">while</span> (arr[j] &gt;= pivot &amp;&amp; i &lt; j) &#123;</span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//i右→_→移  比p小就++  找到一个比p大的索引  和j交换</span></span><br><span class="line">		<span class="keyword">while</span> (arr[i] &lt;= pivot &amp;&amp; i &lt; j) &#123;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//i小于j 交换</span></span><br><span class="line">		<span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">			<span class="keyword">int</span> temp = arr[i];</span><br><span class="line">			arr[i] = arr[j];</span><br><span class="line">			arr[j] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="comment">//end while</span></span><br><span class="line">	<span class="comment">//Pivot modify</span></span><br><span class="line">	arr[left] = arr[i];<span class="comment">//基准点重回左边</span></span><br><span class="line">	arr[i] = pivot;<span class="comment">//pivot给arr[i] arr[i]为中间值</span></span><br><span class="line">	qucikSort(arr, left, i - <span class="number">1</span>);</span><br><span class="line">	qucikSort(arr, i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQuickSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[] arr1 = &#123;<span class="number">23</span>, <span class="number">24</span>, <span class="number">21</span>, <span class="number">5</span>, <span class="number">435</span>, <span class="number">342</span>, <span class="number">54</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">345</span>, <span class="number">2</span>&#125;;</span><br><span class="line">	System.out.println(<span class="string">"快速排序前："</span> + Arrays.toString(arr1));</span><br><span class="line">	SortUtils.qucikSort(arr1, <span class="number">0</span>, arr1.length - <span class="number">1</span>);</span><br><span class="line">	System.out.println(<span class="string">"快速排序后"</span> + Arrays.toString(arr1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="插入排序-直插、希尔"><a href="#插入排序-直插、希尔" class="headerlink" title="插入排序[直插、希尔]"></a>插入排序[直插、希尔]</h1><h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><p>选择一个数与其比较后插入到前面或者后面的位置。类似手动扑克牌排序<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 平均O(n^2),最好O(n),最坏O(n^2);空间复杂度O(1);稳定;简单</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> tmp;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">			<span class="keyword">if</span> (a[j] &lt; a[j - <span class="number">1</span>]) &#123;<span class="comment">//前面的数大时 把大的数交换到后面</span></span><br><span class="line">				tmp = a[j - <span class="number">1</span>];</span><br><span class="line">				a[j - <span class="number">1</span>] = a[j];</span><br><span class="line">				a[j] = tmp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsetSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[] a = &#123;<span class="number">3</span>, <span class="number">22</span>, <span class="number">14</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">	insertionSort(a);</span><br><span class="line">	System.out.println(<span class="string">"after:"</span> + Arrays.toString(a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="希尔排序（步长-增量）"><a href="#希尔排序（步长-增量）" class="headerlink" title="希尔排序（步长/增量）"></a>希尔排序（步长/增量）</h2><p>插入排序的步长为1<br>希尔排序排序任意步长（如:步长初始为数组长度/2）  最后以步长为1结束</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j, temp;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> increment = data.length / <span class="number">2</span>; increment &gt;= <span class="number">1</span>; increment /= <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = increment; i &lt; data.length; i++) &#123;</span><br><span class="line">			temp = data[i];</span><br><span class="line">			<span class="comment">//本质是带增量的插入排序</span></span><br><span class="line">			<span class="keyword">for</span> (j = i - increment; j &gt;= <span class="number">0</span>; j -= increment) &#123;</span><br><span class="line">				<span class="keyword">if</span> (temp &lt; data[j]) &#123;</span><br><span class="line">					data[j + increment] = data[j];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			data[j + increment] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testShellSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[] data = &#123;<span class="number">3</span>, <span class="number">22</span>, <span class="number">14</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">66</span>, <span class="number">99</span>&#125;;</span><br><span class="line">	shellSort(data);</span><br><span class="line">	System.out.println(<span class="string">"after:"</span> + Arrays.toString(data));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="选择排序-直选、堆排序"><a href="#选择排序-直选、堆排序" class="headerlink" title="选择排序[直选、堆排序]"></a>选择排序[直选、堆排序]</h1><h2 id="直接选择排序"><a href="#直接选择排序" class="headerlink" title="直接选择排序"></a>直接选择排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//array[]为待排序数组，n为数组长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span> array[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i, j, min, k;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">			min = i; <span class="comment">//每趟排序最小值先等于第一个数，遍历剩下的数</span></span><br><span class="line">			<span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (array[min] &gt; array[j]) &#123; <span class="comment">//寻找最小的数</span></span><br><span class="line">					min = j; <span class="comment">// 将最小数的索引保存</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (min != i) &#123;</span><br><span class="line">				k = array[min];</span><br><span class="line">				array[min] = array[i];</span><br><span class="line">				array[i] = k;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序的数据结构是二叉树，分为大根堆和小根堆，大根堆的性质:父节点都比子节点大，小根堆反之。如构建好大顶堆后，对其根节点和末节点交换，并移出代表当前数组最大值已找到，调整堆的大小size，最后输出为升序序列。小根堆同理，最后输出降序序列。</p>
<p>堆排序算法步骤：</p>
<ol>
<li>循环构建堆（大顶堆或者小顶堆  注意满足其性质）</li>
<li>循环调整堆 （如大顶堆的根节点与末节点交换移出后 对其堆的大小-1 并调整其大顶堆性质 ）</li>
<li>调整堆性质的函数 （如本代码中的maxHeap() minHeap()）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHeapSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[] array = &#123;<span class="number">3</span>, <span class="number">22</span>, <span class="number">14</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">66</span>, <span class="number">99</span>, <span class="number">24</span>, <span class="number">21</span>&#125;;</span><br><span class="line">	System.out.println(<span class="string">"排序前:"</span> + Arrays.toString(array));</span><br><span class="line">	heapSort(array);</span><br><span class="line">	System.out.println(<span class="string">"排序后:"</span> + Arrays.toString(array));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	buildHeap(array); <span class="comment">// 第一次排序，构建最大堆，只保证了堆顶元素是数组里最大的</span></span><br><span class="line">	<span class="comment">//循环调整堆</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = array.length - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">		swap(array, <span class="number">0</span>, i);<span class="comment">// 目前大顶堆array[0]是当前数组里最大的元素，需要和末尾元素交换，拿出最大元素，</span></span><br><span class="line">		maxHeap(array, i, <span class="number">0</span>);<span class="comment">// 交换完后，然后开始重新构建大顶堆，堆的大小-1，然后从0的位置继续最大堆</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//			minHeap(array, i, 0);//小顶堆</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建堆</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">//对数组进行建堆操作，就是从最后一个非叶结点进行筛选的过程 从下至上 从右到左构建根</span></span><br><span class="line">	<span class="keyword">int</span> rootNum = array.length / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = rootNum; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// i表示根节点的数量 直到i=0 为大顶堆根节点</span></span><br><span class="line">		maxHeap(array, array.length, i);</span><br><span class="line"><span class="comment">//			minHeap(array, array.length, i);//小顶堆 降序</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大堆 堆的公式是 int root = 2*i, int left = 2*i+1, int right = 2*i+2;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">maxHeap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> heapSize, <span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> left = root * <span class="number">2</span> + <span class="number">1</span>; <span class="comment">// 左子节点</span></span><br><span class="line">	<span class="keyword">int</span> right = root * <span class="number">2</span> + <span class="number">2</span>; <span class="comment">// 右子节点</span></span><br><span class="line">	<span class="keyword">int</span> maxValue = root; <span class="comment">// 暂定Index的位置就是最大值</span></span><br><span class="line">	<span class="comment">// 如果左子节点的值，比当前最大的值大，就把最大值的位置换成左子节点的位置</span></span><br><span class="line">	<span class="keyword">if</span> (left &lt; heapSize &amp;&amp; array[left] &gt; array[maxValue]) &#123;</span><br><span class="line">		maxValue = left;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果右子节点的值，比当前最大的值大，就把最大值的位置换成右子节点的位置</span></span><br><span class="line">	<span class="keyword">if</span> (right &lt; heapSize &amp;&amp; array[right] &gt; array[maxValue]) &#123;</span><br><span class="line">		maxValue = right;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果不相等，把大的数交换到root节点</span></span><br><span class="line">	<span class="keyword">if</span> (maxValue != root) &#123;</span><br><span class="line">		swap(array, root, maxValue);</span><br><span class="line">		<span class="comment">// 交换完位置后还需要判断子节点是否打破了最大堆的性质。最大堆性质：两个子节点都比父节点小。</span></span><br><span class="line">		maxHeap(array, heapSize, maxValue);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp = array[a];</span><br><span class="line">	array[a] = array[b];</span><br><span class="line">	array[b] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最小堆同理</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">minHeap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> heapSize, <span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> left = root * <span class="number">2</span> + <span class="number">1</span>; <span class="comment">// 左子节点</span></span><br><span class="line">	<span class="keyword">int</span> right = root * <span class="number">2</span> + <span class="number">2</span>; <span class="comment">// 右子节点</span></span><br><span class="line">	<span class="keyword">int</span> minValue = root; <span class="comment">// 暂时定在Index的位置就是最小值</span></span><br><span class="line">	<span class="comment">// 如果左子节点的值，比当前最小的值小，就把最小值的位置换成左子节点的位置</span></span><br><span class="line">	<span class="keyword">if</span> (left &lt; heapSize &amp;&amp; array[left] &lt; array[minValue]) &#123;</span><br><span class="line">		minValue = left;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//  如果右子节点的值，比当前最小的值小，就把最小值的位置换成左子节点的位置</span></span><br><span class="line">	<span class="keyword">if</span> (right &lt; heapSize &amp;&amp; array[right] &lt; array[minValue]) &#123;</span><br><span class="line">		minValue = right;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (minValue != root) &#123;</span><br><span class="line">		swap(array, root, minValue);</span><br><span class="line">		<span class="comment">// 交换完位置后还需要判断子节点是否打破了最小堆的性质。最小性质：两个子节点都比父节点大。</span></span><br><span class="line">		minHeap(array, heapSize, minValue);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="归并排序（分治递归）"><a href="#归并排序（分治递归）" class="headerlink" title="归并排序（分治递归）"></a>归并排序（分治递归）</h2><p>分解成若干小序列  归并组合排序各个小序列<br><img src="https://ws3.sinaimg.cn/large/006tKfTcly1fr205r4r7oj31d411m0z8.jpg" alt="image"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMergeSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[] data = &#123;<span class="number">3</span>, <span class="number">22</span>, <span class="number">14</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">77</span>&#125;;</span><br><span class="line">	sort(data);</span><br><span class="line">	System.out.println(<span class="string">"归并后:"</span> + Arrays.toString(data));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];<span class="comment">//在排序前，先建好一个长度等于原数组长度的临时数组，避免递归中频繁开辟空间</span></span><br><span class="line">	sort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">		<span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">		sort(arr, left, mid, temp);<span class="comment">//左边归并排序，使得左子序列有序</span></span><br><span class="line">		sort(arr, mid + <span class="number">1</span>, right, temp);<span class="comment">//右边归并排序，使得右子序列有序</span></span><br><span class="line">		merge(arr, left, mid, right, temp);<span class="comment">//将两个有序子数组合并操作</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = left;<span class="comment">//左序列指针</span></span><br><span class="line">	<span class="keyword">int</span> j = mid + <span class="number">1</span>;<span class="comment">//右序列指针</span></span><br><span class="line">	<span class="keyword">int</span> t = <span class="number">0</span>;<span class="comment">//临时数组指针</span></span><br><span class="line">	<span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">		<span class="keyword">if</span> (arr[i] &lt;= arr[j]) &#123;</span><br><span class="line">			temp[t++] = arr[i++];</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			temp[t++] = arr[j++];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (i &lt;= mid) &#123;<span class="comment">//将左边剩余元素填充进temp中</span></span><br><span class="line">		temp[t++] = arr[i++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (j &lt;= right) &#123;<span class="comment">//将右序列剩余元素填充进temp中</span></span><br><span class="line">		temp[t++] = arr[j++];</span><br><span class="line">	&#125;</span><br><span class="line">	t = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//将temp中的元素全部拷贝到原数组中</span></span><br><span class="line">	<span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">		arr[left++] = temp[t++];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="非比较排序-桶排序"><a href="#非比较排序-桶排序" class="headerlink" title="非比较排序[桶排序]"></a>非比较排序[桶排序]</h1><p>桶排序是一种抽象思想是不基于比较的排序 时间复杂度低 但空间复杂度高</p>
<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>如对员工进行身高排序  对100cm - 300cm 建立桶  把员工身高装入对应的桶中 最后从100桶到300桶依次倒出  即是从小到大排列的顺序。 </p>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>基数排序的总体思路就是将待排序数据拆分成多个关键字进行排序，实质是多关键字排序。</p>
<p>多关键字排序的思路是将待排数据里德排序关键字拆分成多个排序关键字；第1个排序关键字，第2个排序关键字，第3个排序关键字……然后，根据子关键字对待排序数据进行排序。</p>
<p>两种算法:<br>最低位优先法（LSD）(Least Significant Digit first) 如个位 十位 百位</p>
<p>最高位优先法（MSD）(Most Significant Digit first) 如百位 十位 个位</p>
<p>下图为LSD排序动画:<br><img src="https://ws1.sinaimg.cn/large/006tKfTcly1fr20bgnhd2g30s40fydky.gif" alt="image"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sherwinxie.xyz/本质能量/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SherwinX">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="谢玮の技术Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/本质能量/" itemprop="url">本质 | 能量（哲思篇)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-15T00:00:00+08:00">
                2018-04-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/探索/" itemprop="url" rel="index">
                    <span itemprop="name">探索</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="哲思篇"><a href="#哲思篇" class="headerlink" title="哲思篇"></a>哲思篇</h1><iframe frameborder="0" width="640" height="498" src="https://v.qq.com/iframe/player.html?vid=k0514w6gdgi&tiny=0&auto=0" allowfullscreen></iframe>

<p>首先，本文参考至该TED视频本体论，如果没有接触过很多佛哲学概念，可能会冲击你以往对世界的认识，请保持一颗开明的心open mind :）</p>
<p>我是什么？</p>
<p>如果用显微镜，观察身体的某一部分，你会看到细胞，细胞也由基本粒子构成，如果再进一步说，我们就是宇宙中的能量，当我们观察身体的任何一部分，其实我们也正在以光的速度移动，映射到眼睛中，传达到大脑里，形成的一个自己看到世界。</p>
<p>那问题是，我们明白这个概念，但我们为什么感觉不到自己只是能量？</p>
<p>其实我们活在大脑创造的世界里，那么，真实本质的世界是什么样的？</p>
<p>我们在物理学中发现，光的本质没有任何颜色，只有频率上的变化，所有的光源都来自电磁场的震动，当光源反射到你的眼中，再传输到你的大脑，你的大脑创造了主观的颜色。</p>
<p>(图为光频率的不同表现形式，颜色是一小部分)</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fr6qqqkx3lj30hs0aodfx.jpg" alt="image"></p>
<p><font color="red">这意味着你所看到的这段带有不同颜色的文字，</font><font color="green">仅存在你的大脑创造的世界里，</font>如果我是红绿色盲的话，你和我在大脑创造的世界里这段话的颜色是不一样的。</p>
<p>所以，你所看见的色，仅发生在你的脑海里。</p>
<p>是不是很诡异？我们的大脑意识无时不刻的在创造一个虚拟的世界，让我们从一开始就产生了幻觉，认为这就是世界的本身？可以想象其他动物和我们”看到”的世界更加不同。</p>
<p>一般会误以为大脑形成的世界的图景就是世界本身，但仔细想想会发现世界可能与大脑形成的图景有所不同，甚至大不相同，我们大脑形成的世界图景至多只是对真实世界的某种程度的摹写。</p>
<p>试着什么都不想，让大脑彻底”空”，即停下创造这个虚拟的世界，很难吧，大概维持2秒就开始想怎样才能让自己什么都不想？当你无法控制脑子里在想什么，你就是被迫的创造了这些。佛学里的五蕴</p>
<p>那什么是真实? 真实是宇宙中没有颜色的存在，万物由原子组成，以能量的形式存在，从始至终，我们一直都是能量，并且永远都会是能量，是高内聚低耦合的能量还是飘忽不定无处不在混为杂糅的能量？</p>
<p>以什么形态，有无形态，我们不得而知，因为我们没有体悟到自己是能量的本质，或是说未开悟，但用一些比喻的话，我们也许能理解为什么”unknown”不得而知且不可被言语描述！</p>
<p>“思想总是被意识的幻觉所折磨”  ——阿尔伯特爱因斯坦</p>
<p>这种幻觉让你觉得你是个独立的个体，但实际上你只是无处不在 无时不刻都在运作的能量，就像海洋是由流动的水组成，我们可以认为是海洋其中的一片海浪，但这也使我们产生幻觉，认为这一片海浪是脱离海洋的个体，但这一片海浪就是大海，同样我们或许也不是海浪，而是整片的海洋。</p>
<p>这样我们能直观地理解，我们都是不可分割的能量，这种领悟是无法用语言解释的，因为是它创造的语言，易经所说形而上谓之道，形成下谓之器，语言是算器的一种，这是为什么语言没法描述，假如要用语言描述，那就会是老子道德经的”道可道非常道”。同如佛学，你只能在实际践行中尽可能的去体悟它，当靠智力从语言上理解是不准和偏差的，佛陀说，切莫信汝意，汝意不可信，得阿罗汉果已，才可信汝意。</p>
<p>几千年来，人们试图为其命名，有人叫它——灵性开悟…等等。</p>
<blockquote>
<p>大约在2500年前，已有人类开始意识到我们的本质是能量，从此以后，所有开悟的人都在说，“灵性的开悟会终结人类的痛苦”，毋庸置疑这将结束人类的苦难，因为所有的痛苦都源于，个体与整体分离的幻觉，幻觉让你觉得，你是一个为生存而挣扎的人，幻觉让你相信你身体里，兆亿的原子只是肉体，然而如果我意识到我是能量，我的身心只是能量所塑造的短暂的幻影，我将欣然地接受生存死亡，我的心智即是幻想，因为真实的我将永远是能量而已，如果我这样思考，那个在我脑海里，操控我的各种声音也将变得苍白无力，未来和过去是幻影，所以唯一重要的一刻就是现在。</p>
</blockquote>
<blockquote>
<p>从冥想了数千个小时的出家人的脑电图中，我们可以看到异常明显的变化，上万亿连在一起的神经元结构，发生了翻天覆地的改变，随着大脑中枢神经，量化的、客观的变化，他们形容自己有一种，无二无别、无穷无尽、混为一体的感觉，在我听来，这像是他们直观地，体验了作为能量的本质，灵性科学必须从古老的，冥想和祈祷中研究出，如何改变人类大脑的结构，才能使人明白他们实际上是能量，我们仍不知道，还要多先进的科学技术，才能使人类彻底醒悟，或许在有生之年，我们可以结束人类的一切苦难，这会是怎样的一个世界：如果世上每一个人，都能感到人与人心连心的完整，当你不再为了自身而挣扎，你人生的着重点即会改变，因为你会觉得全世界就是你自身，你会把别人的痛苦当作自身的痛苦，继而想去帮助他们，也许阻碍我们解决所有问题的根源在于，自己是脱离于世界的个体。</p>
</blockquote>
<blockquote>
<p>“我”到底是什么，虽然令人难以理解，但它无时不刻地与我们同在，“我”即是宇宙的根源，“我”潜藏于我们生命的每一瞬间，就像鱼儿可能永远，不知道自己游在水中，我们可能永远都察觉不到，已被层层包裹住的“真实的自己”，现在你能理解“我”即是空这个概念，它完全没有任何的实质性，但当我亲身经历过它之后，才会有可能意识到，或许我不是个“有意识”的“人”，或许我是一个“化成人形”的“意识”，当我看到这空空如也的“我”，既没有故事，也没有形态，甚至连时间空间的概念也没有，我们其实对此再熟悉不过了。</p>
</blockquote>
<p><strong>也许，这一切都是错觉(Matrix)。我就是一股能量清流，有我也无我，但我确定用大脑创造了自己黄里透着红颜色的双手，翩翩起舞在蝴蝶键盘上谱写下了一篇叫 本质是能量的文章。。</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.gif"
                alt="SherwinX" />
            
              <p class="site-author-name" itemprop="name">SherwinX</p>
              <p class="site-description motion-element" itemprop="description">Doing is better than saying.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/sherwinxie" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:sherwinxie@foxmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SherwinX</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://github.com/sherwinxie">GitHub</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT</a></div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  







  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/canvas_lines.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  




  
  
  
  <link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">

  
  
  <script src="/lib/algolia-instant-search/instantsearch.min.js"></script>
  

  <script src="/js/src/algolia-search.js?v=5.1.4"></script>



  

  

  

  
  

  

  

  

</body>
</html>
